import "./chunk-TDRWH72F.js";
import "./chunk-4IMAOLLG.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_dev,
  append_styles,
  assign,
  attr_dev,
  beforeUpdate,
  binding_callbacks,
  bubble,
  check_outros,
  compute_slots,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  prevent_default,
  prop_dev,
  run_all,
  safe_not_equal,
  set_attributes,
  set_data_dev,
  set_input_value,
  space,
  stop_propagation,
  svg_element,
  text,
  tick,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-ONRLE3LR.js";
import "./chunk-XSLCAIPP.js";
import "./chunk-F3FYYIAV.js";

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element2 = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element2))) != null ? _await$platform$isEle : true) ? element2 : element2.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x,
    y
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element2) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle(element2);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element2) {
  return ["table", "td", "th"].includes(getNodeName(element2));
}
function isContainingBlock(element2) {
  const webkit = isWebKit();
  const css = getComputedStyle(element2);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element2) {
  let currentNode = getParentNode(element2);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle(element2) {
  return getWindow(element2).getComputedStyle(element2);
}
function getNodeScroll(element2) {
  if (isElement(element2)) {
    return {
      scrollLeft: element2.scrollLeft,
      scrollTop: element2.scrollTop
    };
  }
  return {
    scrollLeft: element2.pageXOffset,
    scrollTop: element2.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element2) {
  const css = getComputedStyle(element2);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element2);
  const offsetWidth = hasOffset ? element2.offsetWidth : width;
  const offsetHeight = hasOffset ? element2.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element2) {
  return !isElement(element2) ? element2.contextElement : element2;
}
function getScale(element2) {
  const domElement = unwrapElement(element2);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element2) {
  const win = getWindow(element2);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element2, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element2)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element2, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element2.getBoundingClientRect();
  const domElement = unwrapElement(element2);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element2);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = currentWin.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = currentWin.frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(floating) {
  return topLayerSelectors.some((selector) => {
    try {
      return floating.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element2) {
  return Array.from(element2.getClientRects());
}
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getNodeScroll(element2).scrollLeft;
}
function getDocumentRect(element2) {
  const html = getDocumentElement(element2);
  const scroll = getNodeScroll(element2);
  const body = element2.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element2);
  const y = -scroll.scrollTop;
  if (getComputedStyle(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element2, strategy) {
  const win = getWindow(element2);
  const html = getDocumentElement(element2);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element2, strategy) {
  const clientRect = getBoundingClientRect(element2, true, strategy === "fixed");
  const top = clientRect.top + element2.clientTop;
  const left = clientRect.left + element2.clientLeft;
  const scale = isHTMLElement(element2) ? getScale(element2) : createCoords(1);
  const width = element2.clientWidth * scale.x;
  const height = element2.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element2, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element2, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element2));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element2);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element2, stopNode) {
  const parentNode = getParentNode(element2);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element2, cache) {
  const cachedResult = cache.get(element2);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element2, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle(element2).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element2) : element2;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element2, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element2, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element: element2,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element2, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element2, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element2, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element2) {
  const {
    width,
    height
  } = getCssDimensions(element2);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element2, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element2, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const x = rect.left + scroll.scrollLeft - offsets.x;
  const y = rect.top + scroll.scrollTop - offsets.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent(element2, polyfill) {
  if (!isHTMLElement(element2) || getComputedStyle(element2).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element2);
  }
  return element2.offsetParent;
}
function getOffsetParent(element2, polyfill) {
  const window2 = getWindow(element2);
  if (!isHTMLElement(element2) || isTopLayer(element2)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element2, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      ...await getDimensionsFn(data.floating)
    }
  };
};
function isRTL(element2) {
  return getComputedStyle(element2).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element2, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element2);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element2.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element2);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var shift2 = shift;
var flip2 = flip;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/svelte-floating-ui/index.js
function createFloatingActions(initOptions) {
  let referenceElement;
  let floatingElement;
  const defaultOptions = {
    autoUpdate: true
  };
  let options = initOptions;
  const getOptions = (mixin) => {
    return { ...defaultOptions, ...initOptions || {}, ...mixin || {} };
  };
  const updatePosition = (updateOptions) => {
    if (referenceElement && floatingElement) {
      options = getOptions(updateOptions);
      computePosition2(referenceElement, floatingElement, options).then((v) => {
        Object.assign(floatingElement.style, {
          position: v.strategy,
          left: `${v.x}px`,
          top: `${v.y}px`
        });
        (options == null ? void 0 : options.onComputed) && options.onComputed(v);
      });
    }
  };
  const referenceAction = (node) => {
    if ("subscribe" in node) {
      setupVirtualElementObserver(node);
      return {};
    } else {
      referenceElement = node;
      updatePosition();
    }
  };
  const contentAction = (node, contentOptions) => {
    let autoUpdateDestroy;
    floatingElement = node;
    options = getOptions(contentOptions);
    setTimeout(() => updatePosition(contentOptions), 0);
    updatePosition(contentOptions);
    const destroyAutoUpdate = () => {
      if (autoUpdateDestroy) {
        autoUpdateDestroy();
        autoUpdateDestroy = void 0;
      }
    };
    const initAutoUpdate = ({ autoUpdate: autoUpdate2 } = options || {}) => {
      destroyAutoUpdate();
      if (autoUpdate2 !== false) {
        tick().then(() => {
          return autoUpdate(referenceElement, floatingElement, () => updatePosition(options), autoUpdate2 === true ? {} : autoUpdate2);
        });
      }
      return;
    };
    autoUpdateDestroy = initAutoUpdate();
    return {
      update(contentOptions2) {
        updatePosition(contentOptions2);
        autoUpdateDestroy = initAutoUpdate(contentOptions2);
      },
      destroy() {
        destroyAutoUpdate();
      }
    };
  };
  const setupVirtualElementObserver = (node) => {
    const unsubscribe = node.subscribe(($node) => {
      if (referenceElement === void 0) {
        referenceElement = $node;
        updatePosition();
      } else {
        Object.assign(referenceElement, $node);
        updatePosition();
      }
    });
    onDestroy(unsubscribe);
  };
  return [
    referenceAction,
    contentAction,
    updatePosition
  ];
}

// node_modules/svelte-select/filter.js
function filter({
  loadOptions,
  filterText,
  items,
  multiple,
  value,
  itemId,
  groupBy,
  filterSelectedItems,
  itemFilter,
  convertStringItemsToObjects: convertStringItemsToObjects2,
  filterGroupedItems,
  label
}) {
  if (items && loadOptions)
    return items;
  if (!items)
    return [];
  if (items && items.length > 0 && typeof items[0] !== "object") {
    items = convertStringItemsToObjects2(items);
  }
  let filterResults = items.filter((item) => {
    let matchesFilter = itemFilter(item[label], filterText, item);
    if (matchesFilter && multiple && (value == null ? void 0 : value.length)) {
      matchesFilter = !value.some((x) => {
        return filterSelectedItems ? x[itemId] === item[itemId] : false;
      });
    }
    return matchesFilter;
  });
  if (groupBy) {
    filterResults = filterGroupedItems(filterResults);
  }
  return filterResults;
}

// node_modules/svelte-select/get-items.js
async function getItems({ dispatch, loadOptions, convertStringItemsToObjects: convertStringItemsToObjects2, filterText }) {
  let res = await loadOptions(filterText).catch((err) => {
    console.warn("svelte-select loadOptions error :>> ", err);
    dispatch("error", { type: "loadOptions", details: err });
  });
  if (res && !res.cancelled) {
    if (res) {
      if (res && res.length > 0 && typeof res[0] !== "object") {
        res = convertStringItemsToObjects2(res);
      }
      dispatch("loaded", { items: res });
    } else {
      res = [];
    }
    return {
      filteredItems: res,
      loading: false,
      focused: true,
      listOpen: true
    };
  }
}

// node_modules/svelte-select/ChevronIcon.svelte
var file = "node_modules/svelte-select/ChevronIcon.svelte";
function add_css(target) {
  append_styles(target, "svelte-qbd276", "svg.svelte-qbd276{width:var(--chevron-icon-width, 20px);height:var(--chevron-icon-width, 20px);color:var(--chevron-icon-colour, currentColor)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hldnJvbkljb24uc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9ZdXFpL0Rlc2t0b3AvRmlsZXMvUHJvamVjdHMvc3NiLWdsb2JlL25vZGVfbW9kdWxlcy9zdmVsdGUtc2VsZWN0L0NoZXZyb25JY29uLnN2ZWx0ZSJdfQ== */");
}
function create_fragment(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747\n          3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0\n          1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502\n          0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0\n          0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z");
      add_location(path, file, 6, 4, 114);
      attr_dev(svg, "width", "100%");
      attr_dev(svg, "height", "100%");
      attr_dev(svg, "viewBox", "0 0 20 20");
      attr_dev(svg, "focusable", "false");
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "class", "svelte-qbd276");
      add_location(svg, file, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChevronIcon", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ChevronIcon> was created with unknown prop '${key}'`);
  });
  return [];
}
var ChevronIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChevronIcon",
      options,
      id: create_fragment.name
    });
  }
};
var ChevronIcon_default = ChevronIcon;

// node_modules/svelte-select/ClearIcon.svelte
var file2 = "node_modules/svelte-select/ClearIcon.svelte";
function add_css2(target) {
  append_styles(target, "svelte-whdbu1", "svg.svelte-whdbu1{width:var(--clear-icon-width, 20px);height:var(--clear-icon-width, 20px);color:var(--clear-icon-color, currentColor)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2xlYXJJY29uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyIvVXNlcnMvWXVxaS9EZXNrdG9wL0ZpbGVzL1Byb2plY3RzL3NzYi1nbG9iZS9ub2RlX21vZHVsZXMvc3ZlbHRlLXNlbGVjdC9DbGVhckljb24uc3ZlbHRlIl19 */");
}
function create_fragment2(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124\n    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
      add_location(path, file2, 8, 4, 141);
      attr_dev(svg, "width", "100%");
      attr_dev(svg, "height", "100%");
      attr_dev(svg, "viewBox", "-2 -2 50 50");
      attr_dev(svg, "focusable", "false");
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "role", "presentation");
      attr_dev(svg, "class", "svelte-whdbu1");
      add_location(svg, file2, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ClearIcon", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ClearIcon> was created with unknown prop '${key}'`);
  });
  return [];
}
var ClearIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {}, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ClearIcon",
      options,
      id: create_fragment2.name
    });
  }
};
var ClearIcon_default = ClearIcon;

// node_modules/svelte-select/LoadingIcon.svelte
var file3 = "node_modules/svelte-select/LoadingIcon.svelte";
function add_css3(target) {
  append_styles(target, "svelte-1p3nqvd", ".loading.svelte-1p3nqvd{width:var(--spinner-width, 20px);height:var(--spinner-height, 20px);color:var(--spinner-color, var(--icons-color));animation:svelte-1p3nqvd-rotate 0.75s linear infinite;transform-origin:center center;transform:none}.circle_path.svelte-1p3nqvd{stroke-dasharray:90;stroke-linecap:round}@keyframes svelte-1p3nqvd-rotate{100%{transform:rotate(360deg)}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTG9hZGluZ0ljb24uc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9ZdXFpL0Rlc2t0b3AvRmlsZXMvUHJvamVjdHMvc3NiLWdsb2JlL25vZGVfbW9kdWxlcy9zdmVsdGUtc2VsZWN0L0xvYWRpbmdJY29uLnN2ZWx0ZSJdfQ== */");
}
function create_fragment3(ctx) {
  let svg;
  let circle;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      attr_dev(circle, "class", "circle_path svelte-1p3nqvd");
      attr_dev(circle, "cx", "50");
      attr_dev(circle, "cy", "50");
      attr_dev(circle, "r", "20");
      attr_dev(circle, "fill", "none");
      attr_dev(circle, "stroke", "currentColor");
      attr_dev(circle, "stroke-width", "5");
      attr_dev(circle, "stroke-miterlimit", "10");
      add_location(circle, file3, 1, 4, 48);
      attr_dev(svg, "class", "loading svelte-1p3nqvd");
      attr_dev(svg, "viewBox", "25 25 50 50");
      add_location(svg, file3, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, circle);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LoadingIcon", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LoadingIcon> was created with unknown prop '${key}'`);
  });
  return [];
}
var LoadingIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LoadingIcon",
      options,
      id: create_fragment3.name
    });
  }
};
var LoadingIcon_default = LoadingIcon;

// node_modules/svelte-select/Select.svelte
var { Object: Object_1 } = globals;
var file4 = "node_modules/svelte-select/Select.svelte";
function add_css4(target) {
  append_styles(target, "svelte-u3g5ju", ".svelte-select.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{--borderRadius:var(--border-radius);--clearSelectColor:var(--clear-select-color);--clearSelectWidth:var(--clear-select-width);--disabledBackground:var(--disabled-background);--disabledBorderColor:var(--disabled-border-color);--disabledColor:var(--disabled-color);--disabledPlaceholderColor:var(--disabled-placeholder-color);--disabledPlaceholderOpacity:var(--disabled-placeholder-opacity);--errorBackground:var(--error-background);--errorBorder:var(--error-border);--groupItemPaddingLeft:var(--group-item-padding-left);--groupTitleColor:var(--group-title-color);--groupTitleFontSize:var(--group-title-font-size);--groupTitleFontWeight:var(--group-title-font-weight);--groupTitlePadding:var(--group-title-padding);--groupTitleTextTransform:var(--group-title-text-transform);--groupTitleBorderColor:var(--group-title-border-color);--groupTitleBorderWidth:var(--group-title-border-width);--groupTitleBorderStyle:var(--group-title-border-style);--indicatorColor:var(--chevron-color);--indicatorHeight:var(--chevron-height);--indicatorWidth:var(--chevron-width);--inputColor:var(--input-color);--inputLeft:var(--input-left);--inputLetterSpacing:var(--input-letter-spacing);--inputMargin:var(--input-margin);--inputPadding:var(--input-padding);--itemActiveBackground:var(--item-active-background);--itemColor:var(--item-color);--itemFirstBorderRadius:var(--item-first-border-radius);--itemHoverBG:var(--item-hover-bg);--itemHoverColor:var(--item-hover-color);--itemIsActiveBG:var(--item-is-active-bg);--itemIsActiveColor:var(--item-is-active-color);--itemIsNotSelectableColor:var(--item-is-not-selectable-color);--itemPadding:var(--item-padding);--listBackground:var(--list-background);--listBorder:var(--list-border);--listBorderRadius:var(--list-border-radius);--listEmptyColor:var(--list-empty-color);--listEmptyPadding:var(--list-empty-padding);--listEmptyTextAlign:var(--list-empty-text-align);--listMaxHeight:var(--list-max-height);--listPosition:var(--list-position);--listShadow:var(--list-shadow);--listZIndex:var(--list-z-index);--multiItemBG:var(--multi-item-bg);--multiItemBorderRadius:var(--multi-item-border-radius);--multiItemDisabledHoverBg:var(--multi-item-disabled-hover-bg);--multiItemDisabledHoverColor:var(--multi-item-disabled-hover-color);--multiItemHeight:var(--multi-item-height);--multiItemMargin:var(--multi-item-margin);--multiItemPadding:var(--multi-item-padding);--multiSelectInputMargin:var(--multi-select-input-margin);--multiSelectInputPadding:var(--multi-select-input-padding);--multiSelectPadding:var(--multi-select-padding);--placeholderColor:var(--placeholder-color);--placeholderOpacity:var(--placeholder-opacity);--selectedItemPadding:var(--selected-item-padding);--spinnerColor:var(--spinner-color);--spinnerHeight:var(--spinner-height);--spinnerWidth:var(--spinner-width);--internal-padding:0 0 0 16px;border:var(--border, 1px solid #d8dbdf);border-radius:var(--border-radius, 6px);min-height:var(--height, 42px);position:relative;display:flex;align-items:stretch;padding:var(--padding, var(--internal-padding));background:var(--background, #fff);margin:var(--margin, 0);width:var(--width, 100%);font-size:var(--font-size, 16px);max-height:var(--max-height)}.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{box-sizing:var(--box-sizing, border-box)}.svelte-select.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju:hover{border:var(--border-hover, 1px solid #b2b8bf)}.value-container.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{display:flex;flex:1 1 0%;flex-wrap:wrap;align-items:center;gap:5px 10px;padding:var(--value-container-padding, 5px 0);position:relative;overflow:var(--value-container-overflow, hidden);align-self:stretch}.prepend.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju,.indicators.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{display:flex;flex-shrink:0;align-items:center}.indicators.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{position:var(--indicators-position);top:var(--indicators-top);right:var(--indicators-right);bottom:var(--indicators-bottom)}input.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{position:absolute;cursor:default;border:none;color:var(--input-color, var(--item-color));padding:var(--input-padding, 0);letter-spacing:var(--input-letter-spacing, inherit);margin:var(--input-margin, 0);min-width:10px;top:0;right:0;bottom:0;left:0;background:transparent;font-size:var(--font-size, 16px)}.svelte-u3g5ju:not(.multi)>.value-container.svelte-u3g5ju>input.svelte-u3g5ju{width:100%;height:100%}input.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju::-moz-placeholder{color:var(--placeholder-color, #78848f);opacity:var(--placeholder-opacity, 1)}input.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju::placeholder{color:var(--placeholder-color, #78848f);opacity:var(--placeholder-opacity, 1)}input.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju:focus{outline:none}.svelte-select.focused.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{border:var(--border-focused, 1px solid #006fe8);border-radius:var(--border-radius-focused, var(--border-radius, 6px))}.disabled.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{background:var(--disabled-background, #ebedef);border-color:var(--disabled-border-color, #ebedef);color:var(--disabled-color, #c1c6cc)}.disabled.svelte-u3g5ju input.svelte-u3g5ju.svelte-u3g5ju::-moz-placeholder{color:var(--disabled-placeholder-color, #c1c6cc);opacity:var(--disabled-placeholder-opacity, 1)}.disabled.svelte-u3g5ju input.svelte-u3g5ju.svelte-u3g5ju::placeholder{color:var(--disabled-placeholder-color, #c1c6cc);opacity:var(--disabled-placeholder-opacity, 1)}.selected-item.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{position:relative;overflow:var(--selected-item-overflow, hidden);padding:var(--selected-item-padding, 0 20px 0 0);text-overflow:ellipsis;white-space:nowrap;color:var(--selected-item-color, inherit);font-size:var(--font-size, 16px)}.multi.svelte-u3g5ju .selected-item.svelte-u3g5ju.svelte-u3g5ju{position:absolute;line-height:var(--height, 42px);height:var(--height, 42px)}.selected-item.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju:focus{outline:none}.hide-selected-item.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{opacity:0}.icon.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{display:flex;align-items:center;justify-content:center}.clear-select.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{all:unset;display:flex;align-items:center;justify-content:center;width:var(--clear-select-width, 40px);height:var(--clear-select-height, 100%);color:var(--clear-select-color, var(--icons-color));margin:var(--clear-select-margin, 0);pointer-events:all;flex-shrink:0}.clear-select.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju:focus{outline:var(--clear-select-focus-outline, 1px solid #006fe8)}.loading.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{width:var(--loading-width, 40px);height:var(--loading-height);color:var(--loading-color, var(--icons-color));margin:var(--loading--margin, 0);flex-shrink:0}.chevron.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{width:var(--chevron-width, 40px);height:var(--chevron-height, 40px);background:var(--chevron-background, transparent);pointer-events:var(--chevron-pointer-events, none);color:var(--chevron-color, var(--icons-color));border:var(--chevron-border, 0 0 0 1px solid #d8dbdf);flex-shrink:0}.multi.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{padding:var(--multi-select-padding, var(--internal-padding))}.multi.svelte-u3g5ju input.svelte-u3g5ju.svelte-u3g5ju{padding:var(--multi-select-input-padding, 0);position:relative;margin:var(--multi-select-input-margin, 5px 0);flex:1 1 40px}.svelte-select.error.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{border:var(--error-border, 1px solid #ff2d55);background:var(--error-background, #fff)}.a11y-text.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{z-index:9999;border:0px;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0px;white-space:nowrap}.multi-item.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{background:var(--multi-item-bg, #ebedef);margin:var(--multi-item-margin, 0);outline:var(--multi-item-outline, 1px solid #ddd);border-radius:var(--multi-item-border-radius, 4px);height:var(--multi-item-height, 25px);line-height:var(--multi-item-height, 25px);display:flex;cursor:default;padding:var(--multi-item-padding, 0 5px);overflow:hidden;gap:var(--multi-item-gap, 4px);outline-offset:-1px;max-width:var(--multi-max-width, none);color:var(--multi-item-color, var(--item-color))}.multi-item.disabled.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju:hover{background:var(--multi-item-disabled-hover-bg, #ebedef);color:var(--multi-item-disabled-hover-color, #c1c6cc)}.multi-item-text.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.multi-item-clear.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{display:flex;align-items:center;justify-content:center;--clear-icon-color:var(--multi-item-clear-icon-color, #000)}.multi-item.active.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{outline:var(--multi-item-active-outline, 1px solid #006fe8)}.svelte-select-list.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{box-shadow:var(--list-shadow, 0 2px 3px 0 rgba(44, 62, 80, 0.24));border-radius:var(--list-border-radius, 4px);max-height:var(--list-max-height, 252px);overflow-y:auto;background:var(--list-background, #fff);position:var(--list-position, absolute);z-index:var(--list-z-index, 2);border:var(--list-border)}.prefloat.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{opacity:0;pointer-events:none}.list-group-title.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{color:var(--group-title-color, #8f8f8f);cursor:default;font-size:var(--group-title-font-size, 16px);font-weight:var(--group-title-font-weight, 600);height:var(--height, 42px);line-height:var(--height, 42px);padding:var(--group-title-padding, 0 20px);text-overflow:ellipsis;overflow-x:hidden;white-space:nowrap;text-transform:var(--group-title-text-transform, uppercase);border-width:var(--group-title-border-width, medium);border-style:var(--group-title-border-style, none);border-color:var(--group-title-border-color, color)}.empty.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{text-align:var(--list-empty-text-align, center);padding:var(--list-empty-padding, 20px 0);color:var(--list-empty-color, #78848f)}.item.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{cursor:default;height:var(--item-height, var(--height, 42px));line-height:var(--item-line-height, var(--height, 42px));padding:var(--item-padding, 0 20px);color:var(--item-color, inherit);text-overflow:ellipsis;overflow:hidden;white-space:nowrap;transition:var(--item-transition, all 0.2s);align-items:center;width:100%}.item.group-item.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{padding-left:var(--group-item-padding-left, 40px)}.item.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju:active{background:var(--item-active-background, #b9daff)}.item.active.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{background:var(--item-is-active-bg, #007aff);color:var(--item-is-active-color, #fff)}.item.first.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{border-radius:var(--item-first-border-radius, 4px 4px 0 0)}.item.hover.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju:not(.active){background:var(--item-hover-bg, #e7f2ff);color:var(--item-hover-color, inherit)}.item.not-selectable.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju,.item.hover.item.not-selectable.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju,.item.active.item.not-selectable.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju,.item.not-selectable.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju:active{color:var(--item-is-not-selectable-color, #999);background:transparent}.required.svelte-u3g5ju.svelte-u3g5ju.svelte-u3g5ju{opacity:0;z-index:-1;position:absolute;top:0;left:0;bottom:0;right:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VsZWN0LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyIvVXNlcnMvWXVxaS9EZXNrdG9wL0ZpbGVzL1Byb2plY3RzL3NzYi1nbG9iZS9ub2RlX21vZHVsZXMvc3ZlbHRlLXNlbGVjdC9TZWxlY3Quc3ZlbHRlIl19 */");
}
var get_required_slot_changes = (dirty) => ({ value: dirty[0] & /*value*/
8 });
var get_required_slot_context = (ctx) => ({ value: (
  /*value*/
  ctx[3]
) });
var get_input_hidden_slot_changes = (dirty) => ({ value: dirty[0] & /*value*/
8 });
var get_input_hidden_slot_context = (ctx) => ({ value: (
  /*value*/
  ctx[3]
) });
var get_chevron_icon_slot_changes = (dirty) => ({ listOpen: dirty[0] & /*listOpen*/
64 });
var get_chevron_icon_slot_context = (ctx) => ({ listOpen: (
  /*listOpen*/
  ctx[6]
) });
var get_clear_icon_slot_changes = (dirty) => ({});
var get_clear_icon_slot_context = (ctx) => ({});
var get_loading_icon_slot_changes = (dirty) => ({});
var get_loading_icon_slot_context = (ctx) => ({});
var get_selection_slot_changes_1 = (dirty) => ({ selection: dirty[0] & /*value*/
8 });
var get_selection_slot_context_1 = (ctx) => ({ selection: (
  /*value*/
  ctx[3]
) });
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[126] = list[i];
  child_ctx[128] = i;
  return child_ctx;
}
var get_multi_clear_icon_slot_changes = (dirty) => ({});
var get_multi_clear_icon_slot_context = (ctx) => ({});
var get_selection_slot_changes = (dirty) => ({ selection: dirty[0] & /*value*/
8 });
var get_selection_slot_context = (ctx) => ({
  selection: (
    /*item*/
    ctx[126]
  ),
  index: (
    /*i*/
    ctx[128]
  )
});
var get_prepend_slot_changes = (dirty) => ({});
var get_prepend_slot_context = (ctx) => ({});
var get_list_append_slot_changes = (dirty) => ({});
var get_list_append_slot_context = (ctx) => ({});
var get_empty_slot_changes = (dirty) => ({});
var get_empty_slot_context = (ctx) => ({});
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[126] = list[i];
  child_ctx[128] = i;
  return child_ctx;
}
var get_item_slot_changes = (dirty) => ({
  item: dirty[0] & /*filteredItems*/
  16777216
});
var get_item_slot_context = (ctx) => ({
  item: (
    /*item*/
    ctx[126]
  ),
  index: (
    /*i*/
    ctx[128]
  )
});
var get_list_slot_changes = (dirty) => ({
  filteredItems: dirty[0] & /*filteredItems*/
  16777216
});
var get_list_slot_context = (ctx) => ({ filteredItems: (
  /*filteredItems*/
  ctx[24]
) });
var get_list_prepend_slot_changes = (dirty) => ({});
var get_list_prepend_slot_context = (ctx) => ({});
function create_if_block_8(ctx) {
  let div;
  let t0;
  let current_block_type_index;
  let if_block1;
  let t1;
  let floatingContent_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$$slots*/
    ctx[50]["list-prepend"] && create_if_block_13(ctx)
  );
  const if_block_creators = [create_if_block_10, create_if_block_11, create_if_block_12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[50].list
    )
      return 0;
    if (
      /*filteredItems*/
      ctx2[24].length > 0
    )
      return 1;
    if (!/*hideEmptyState*/
    ctx2[19])
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, [-1, -1, -1, -1, -1]))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block2 = (
    /*$$slots*/
    ctx[50]["list-append"] && create_if_block_9(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      attr_dev(div, "class", "svelte-select-list svelte-u3g5ju");
      attr_dev(div, "role", "none");
      toggle_class(
        div,
        "prefloat",
        /*prefloat*/
        ctx[28]
      );
      add_location(div, file4, 686, 8, 21006);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      append_dev(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      ctx[91](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(floatingContent_action = /*floatingContent*/
          ctx[49].call(null, div)),
          listen_dev(
            div,
            "scroll",
            /*handleListScroll*/
            ctx[41],
            false,
            false,
            false,
            false
          ),
          listen_dev(div, "pointerup", stop_propagation(prevent_default(
            /*pointerup_handler*/
            ctx[85]
          )), false, true, true, false),
          listen_dev(div, "mousedown", stop_propagation(prevent_default(
            /*mousedown_handler*/
            ctx[86]
          )), false, true, true, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[50]["list-prepend"]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*$$slots*/
          524288) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_13(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        } else {
          if_block1 = null;
        }
      }
      if (
        /*$$slots*/
        ctx2[50]["list-append"]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[1] & /*$$slots*/
          524288) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_9(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*prefloat*/
      268435456) {
        toggle_class(
          div,
          "prefloat",
          /*prefloat*/
          ctx2[28]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block0)
        if_block0.d();
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block2)
        if_block2.d();
      ctx[91](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(686:4) {#if listOpen}",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let current;
  const list_prepend_slot_template = (
    /*#slots*/
    ctx[83]["list-prepend"]
  );
  const list_prepend_slot = create_slot(
    list_prepend_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_list_prepend_slot_context
  );
  const block = {
    c: function create() {
      if (list_prepend_slot)
        list_prepend_slot.c();
    },
    m: function mount(target, anchor) {
      if (list_prepend_slot) {
        list_prepend_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (list_prepend_slot) {
        if (list_prepend_slot.p && (!current || dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            list_prepend_slot,
            list_prepend_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              list_prepend_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_list_prepend_slot_changes
            ),
            get_list_prepend_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(list_prepend_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(list_prepend_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (list_prepend_slot)
        list_prepend_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(696:12) {#if $$slots['list-prepend']}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let current;
  const empty_slot_template = (
    /*#slots*/
    ctx[83].empty
  );
  const empty_slot = create_slot(
    empty_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_empty_slot_context
  );
  const empty_slot_or_fallback = empty_slot || fallback_block_9(ctx);
  const block = {
    c: function create() {
      if (empty_slot_or_fallback)
        empty_slot_or_fallback.c();
    },
    m: function mount(target, anchor) {
      if (empty_slot_or_fallback) {
        empty_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (empty_slot) {
        if (empty_slot.p && (!current || dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            empty_slot,
            empty_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              empty_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_empty_slot_changes
            ),
            get_empty_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(empty_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(empty_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (empty_slot_or_fallback)
        empty_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(724:38) ",
    ctx
  });
  return block;
}
function create_if_block_11(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like_dev(
    /*filteredItems*/
    ctx[24]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*filteredItems, value, itemId, listDom, scrollToHoverItem, hoverItemIndex, label*/
      1627402376 | dirty[1] & /*handleHover, handleItemClick, isItemActive*/
      28672 | dirty[2] & /*$$scope*/
      1048576) {
        each_value_1 = ensure_array_like_dev(
          /*filteredItems*/
          ctx2[24]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_11.name,
    type: "if",
    source: "(698:47) ",
    ctx
  });
  return block;
}
function create_if_block_10(ctx) {
  let current;
  const list_slot_template = (
    /*#slots*/
    ctx[83].list
  );
  const list_slot = create_slot(
    list_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_list_slot_context
  );
  const block = {
    c: function create() {
      if (list_slot)
        list_slot.c();
    },
    m: function mount(target, anchor) {
      if (list_slot) {
        list_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (list_slot) {
        if (list_slot.p && (!current || dirty[0] & /*filteredItems*/
        16777216 | dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            list_slot,
            list_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              list_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_list_slot_changes
            ),
            get_list_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(list_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(list_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (list_slot)
        list_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(697:12) {#if $$slots.list}",
    ctx
  });
  return block;
}
function fallback_block_9(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      div.textContent = "No options";
      attr_dev(div, "class", "empty svelte-u3g5ju");
      add_location(div, file4, 725, 20, 22952);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_9.name,
    type: "fallback",
    source: "(725:35)                      ",
    ctx
  });
  return block;
}
function fallback_block_8(ctx) {
  var _a;
  let t_value = (
    /*item*/
    ((_a = ctx[126]) == null ? void 0 : _a[
      /*label*/
      ctx[12]
    ]) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2;
      if (dirty[0] & /*filteredItems, label*/
      16781312 && t_value !== (t_value = /*item*/
      ((_a2 = ctx2[126]) == null ? void 0 : _a2[
        /*label*/
        ctx2[12]
      ]) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_8.name,
    type: "fallback",
    source: "(718:63)                                  ",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let div1;
  let div0;
  let activeScroll_action;
  let hoverScroll_action;
  let t;
  let current;
  let mounted;
  let dispose;
  const item_slot_template = (
    /*#slots*/
    ctx[83].item
  );
  const item_slot = create_slot(
    item_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_item_slot_context
  );
  const item_slot_or_fallback = item_slot || fallback_block_8(ctx);
  function mouseover_handler() {
    return (
      /*mouseover_handler*/
      ctx[88](
        /*i*/
        ctx[128]
      )
    );
  }
  function focus_handler() {
    return (
      /*focus_handler*/
      ctx[89](
        /*i*/
        ctx[128]
      )
    );
  }
  function click_handler() {
    return (
      /*click_handler*/
      ctx[90](
        /*item*/
        ctx[126],
        /*i*/
        ctx[128]
      )
    );
  }
  const block = {
    c: function create() {
      var _a;
      div1 = element("div");
      div0 = element("div");
      if (item_slot_or_fallback)
        item_slot_or_fallback.c();
      t = space();
      attr_dev(div0, "class", "item svelte-u3g5ju");
      toggle_class(
        div0,
        "list-group-title",
        /*item*/
        ctx[126].groupHeader
      );
      toggle_class(
        div0,
        "active",
        /*isItemActive*/
        ctx[45](
          /*item*/
          ctx[126],
          /*value*/
          ctx[3],
          /*itemId*/
          ctx[13]
        )
      );
      toggle_class(div0, "first", isItemFirst(
        /*i*/
        ctx[128]
      ));
      toggle_class(
        div0,
        "hover",
        /*hoverItemIndex*/
        ctx[7] === /*i*/
        ctx[128]
      );
      toggle_class(
        div0,
        "group-item",
        /*item*/
        ctx[126].groupItem
      );
      toggle_class(
        div0,
        "not-selectable",
        /*item*/
        ((_a = ctx[126]) == null ? void 0 : _a.selectable) === false
      );
      add_location(div0, file4, 707, 24, 21980);
      attr_dev(div1, "class", "list-item svelte-u3g5ju");
      attr_dev(div1, "tabindex", "-1");
      attr_dev(div1, "role", "none");
      add_location(div1, file4, 699, 20, 21566);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      if (item_slot_or_fallback) {
        item_slot_or_fallback.m(div0, null);
      }
      append_dev(div1, t);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(activeScroll_action = /*activeScroll*/
          ctx[46].call(null, div0, {
            scroll: (
              /*isItemActive*/
              ctx[45](
                /*item*/
                ctx[126],
                /*value*/
                ctx[3],
                /*itemId*/
                ctx[13]
              )
            ),
            listDom: (
              /*listDom*/
              ctx[30]
            )
          })),
          action_destroyer(hoverScroll_action = /*hoverScroll*/
          ctx[47].call(null, div0, {
            scroll: (
              /*scrollToHoverItem*/
              ctx[29] === /*i*/
              ctx[128]
            ),
            listDom: (
              /*listDom*/
              ctx[30]
            )
          })),
          listen_dev(div1, "mouseover", mouseover_handler, false, false, false, false),
          listen_dev(div1, "focus", focus_handler, false, false, false, false),
          listen_dev(div1, "click", stop_propagation(click_handler), false, false, true, false),
          listen_dev(div1, "keydown", stop_propagation(prevent_default(
            /*keydown_handler*/
            ctx[87]
          )), false, true, true, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      var _a;
      ctx = new_ctx;
      if (item_slot) {
        if (item_slot.p && (!current || dirty[0] & /*filteredItems*/
        16777216 | dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            item_slot,
            item_slot_template,
            ctx,
            /*$$scope*/
            ctx[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[82]
            ) : get_slot_changes(
              item_slot_template,
              /*$$scope*/
              ctx[82],
              dirty,
              get_item_slot_changes
            ),
            get_item_slot_context
          );
        }
      } else {
        if (item_slot_or_fallback && item_slot_or_fallback.p && (!current || dirty[0] & /*filteredItems, label*/
        16781312)) {
          item_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
        }
      }
      if (activeScroll_action && is_function(activeScroll_action.update) && dirty[0] & /*filteredItems, value, itemId, listDom*/
      1090527240)
        activeScroll_action.update.call(null, {
          scroll: (
            /*isItemActive*/
            ctx[45](
              /*item*/
              ctx[126],
              /*value*/
              ctx[3],
              /*itemId*/
              ctx[13]
            )
          ),
          listDom: (
            /*listDom*/
            ctx[30]
          )
        });
      if (hoverScroll_action && is_function(hoverScroll_action.update) && dirty[0] & /*scrollToHoverItem, listDom*/
      1610612736)
        hoverScroll_action.update.call(null, {
          scroll: (
            /*scrollToHoverItem*/
            ctx[29] === /*i*/
            ctx[128]
          ),
          listDom: (
            /*listDom*/
            ctx[30]
          )
        });
      if (!current || dirty[0] & /*filteredItems*/
      16777216) {
        toggle_class(
          div0,
          "list-group-title",
          /*item*/
          ctx[126].groupHeader
        );
      }
      if (!current || dirty[0] & /*filteredItems, value, itemId*/
      16785416 | dirty[1] & /*isItemActive*/
      16384) {
        toggle_class(
          div0,
          "active",
          /*isItemActive*/
          ctx[45](
            /*item*/
            ctx[126],
            /*value*/
            ctx[3],
            /*itemId*/
            ctx[13]
          )
        );
      }
      if (!current || dirty[0] & /*hoverItemIndex*/
      128) {
        toggle_class(
          div0,
          "hover",
          /*hoverItemIndex*/
          ctx[7] === /*i*/
          ctx[128]
        );
      }
      if (!current || dirty[0] & /*filteredItems*/
      16777216) {
        toggle_class(
          div0,
          "group-item",
          /*item*/
          ctx[126].groupItem
        );
      }
      if (!current || dirty[0] & /*filteredItems*/
      16777216) {
        toggle_class(
          div0,
          "not-selectable",
          /*item*/
          ((_a = ctx[126]) == null ? void 0 : _a.selectable) === false
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(item_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(item_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (item_slot_or_fallback)
        item_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(699:16) {#each filteredItems as item, i}",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let current;
  const list_append_slot_template = (
    /*#slots*/
    ctx[83]["list-append"]
  );
  const list_append_slot = create_slot(
    list_append_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_list_append_slot_context
  );
  const block = {
    c: function create() {
      if (list_append_slot)
        list_append_slot.c();
    },
    m: function mount(target, anchor) {
      if (list_append_slot) {
        list_append_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (list_append_slot) {
        if (list_append_slot.p && (!current || dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            list_append_slot,
            list_append_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              list_append_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_list_append_slot_changes
            ),
            get_list_append_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(list_append_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(list_append_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (list_append_slot)
        list_append_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(729:12) {#if $$slots['list-append']}",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let span0;
  let t0;
  let t1;
  let span1;
  let t2;
  const block = {
    c: function create() {
      span0 = element("span");
      t0 = text(
        /*ariaSelection*/
        ctx[32]
      );
      t1 = space();
      span1 = element("span");
      t2 = text(
        /*ariaContext*/
        ctx[31]
      );
      attr_dev(span0, "id", "aria-selection");
      attr_dev(span0, "class", "svelte-u3g5ju");
      add_location(span0, file4, 734, 12, 23262);
      attr_dev(span1, "id", "aria-context");
      attr_dev(span1, "class", "svelte-u3g5ju");
      add_location(span1, file4, 735, 12, 23323);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span0, anchor);
      append_dev(span0, t0);
      insert_dev(target, t1, anchor);
      insert_dev(target, span1, anchor);
      append_dev(span1, t2);
    },
    p: function update(ctx2, dirty) {
      if (dirty[1] & /*ariaSelection*/
      2)
        set_data_dev(
          t0,
          /*ariaSelection*/
          ctx2[32]
        );
      if (dirty[1] & /*ariaContext*/
      1)
        set_data_dev(
          t2,
          /*ariaContext*/
          ctx2[31]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span0);
        detach_dev(t1);
        detach_dev(span1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(734:8) {#if focused}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_5, create_else_block];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*multiple*/
      ctx2[9]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(747:8) {#if hasValue}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let div;
  let current;
  const selection_slot_template = (
    /*#slots*/
    ctx[83].selection
  );
  const selection_slot = create_slot(
    selection_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_selection_slot_context_1
  );
  const selection_slot_or_fallback = selection_slot || fallback_block_7(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (selection_slot_or_fallback)
        selection_slot_or_fallback.c();
      attr_dev(div, "class", "selected-item svelte-u3g5ju");
      toggle_class(
        div,
        "hide-selected-item",
        /*hideSelectedItem*/
        ctx[35]
      );
      add_location(div, file4, 774, 16, 24832);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (selection_slot_or_fallback) {
        selection_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (selection_slot) {
        if (selection_slot.p && (!current || dirty[0] & /*value*/
        8 | dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            selection_slot,
            selection_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              selection_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_selection_slot_changes_1
            ),
            get_selection_slot_context_1
          );
        }
      } else {
        if (selection_slot_or_fallback && selection_slot_or_fallback.p && (!current || dirty[0] & /*value, label*/
        4104)) {
          selection_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1, -1, -1] : dirty);
        }
      }
      if (!current || dirty[1] & /*hideSelectedItem*/
      16) {
        toggle_class(
          div,
          "hide-selected-item",
          /*hideSelectedItem*/
          ctx2[35]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(selection_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(selection_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (selection_slot_or_fallback)
        selection_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(774:12) {:else}",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*value*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*activeValue, disabled, multiFullItemClearable, value, label*/
      67116040 | dirty[1] & /*handleMultiItemClear*/
      32 | dirty[2] & /*$$scope*/
      1048576) {
        each_value = ensure_array_like_dev(
          /*value*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(748:12) {#if multiple}",
    ctx
  });
  return block;
}
function fallback_block_7(ctx) {
  let t_value = (
    /*value*/
    ctx[3][
      /*label*/
      ctx[12]
    ] + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*value, label*/
      4104 && t_value !== (t_value = /*value*/
      ctx2[3][
        /*label*/
        ctx2[12]
      ] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_7.name,
    type: "fallback",
    source: "(776:61)                          ",
    ctx
  });
  return block;
}
function fallback_block_6(ctx) {
  let t_value = (
    /*item*/
    ctx[126][
      /*label*/
      ctx[12]
    ] + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*value, label*/
      4104 && t_value !== (t_value = /*item*/
      ctx2[126][
        /*label*/
        ctx2[12]
      ] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_6.name,
    type: "fallback",
    source: "(758:78)                                  ",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const multi_clear_icon_slot_template = (
    /*#slots*/
    ctx[83]["multi-clear-icon"]
  );
  const multi_clear_icon_slot = create_slot(
    multi_clear_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_multi_clear_icon_slot_context
  );
  const multi_clear_icon_slot_or_fallback = multi_clear_icon_slot || fallback_block_5(ctx);
  function pointerup_handler_1() {
    return (
      /*pointerup_handler_1*/
      ctx[92](
        /*i*/
        ctx[128]
      )
    );
  }
  const block = {
    c: function create() {
      div = element("div");
      if (multi_clear_icon_slot_or_fallback)
        multi_clear_icon_slot_or_fallback.c();
      attr_dev(div, "class", "multi-item-clear svelte-u3g5ju");
      add_location(div, file4, 763, 28, 24356);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (multi_clear_icon_slot_or_fallback) {
        multi_clear_icon_slot_or_fallback.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(div, "pointerup", stop_propagation(prevent_default(pointerup_handler_1)), false, true, true, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (multi_clear_icon_slot) {
        if (multi_clear_icon_slot.p && (!current || dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            multi_clear_icon_slot,
            multi_clear_icon_slot_template,
            ctx,
            /*$$scope*/
            ctx[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[82]
            ) : get_slot_changes(
              multi_clear_icon_slot_template,
              /*$$scope*/
              ctx[82],
              dirty,
              get_multi_clear_icon_slot_changes
            ),
            get_multi_clear_icon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(multi_clear_icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(multi_clear_icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (multi_clear_icon_slot_or_fallback)
        multi_clear_icon_slot_or_fallback.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(763:24) {#if !disabled && !multiFullItemClearable && ClearIcon}",
    ctx
  });
  return block;
}
function fallback_block_5(ctx) {
  let clearicon;
  let current;
  clearicon = new ClearIcon_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(clearicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(clearicon, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(clearicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(clearicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(clearicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_5.name,
    type: "fallback",
    source: "(767:62)                                      ",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let div;
  let span;
  let t0;
  let t1;
  let current;
  let mounted;
  let dispose;
  const selection_slot_template = (
    /*#slots*/
    ctx[83].selection
  );
  const selection_slot = create_slot(
    selection_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_selection_slot_context
  );
  const selection_slot_or_fallback = selection_slot || fallback_block_6(ctx);
  let if_block = !/*disabled*/
  ctx[11] && !/*multiFullItemClearable*/
  ctx[10] && ClearIcon_default && create_if_block_6(ctx);
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[93](
        /*i*/
        ctx[128]
      )
    );
  }
  const block = {
    c: function create() {
      div = element("div");
      span = element("span");
      if (selection_slot_or_fallback)
        selection_slot_or_fallback.c();
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      attr_dev(span, "class", "multi-item-text svelte-u3g5ju");
      add_location(span, file4, 756, 24, 24023);
      attr_dev(div, "class", "multi-item svelte-u3g5ju");
      attr_dev(div, "role", "none");
      toggle_class(
        div,
        "active",
        /*activeValue*/
        ctx[26] === /*i*/
        ctx[128]
      );
      toggle_class(
        div,
        "disabled",
        /*disabled*/
        ctx[11]
      );
      add_location(div, file4, 749, 20, 23640);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, span);
      if (selection_slot_or_fallback) {
        selection_slot_or_fallback.m(span, null);
      }
      append_dev(div, t0);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", prevent_default(click_handler_1), false, true, false, false),
          listen_dev(div, "keydown", stop_propagation(prevent_default(
            /*keydown_handler_1*/
            ctx[84]
          )), false, true, true, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (selection_slot) {
        if (selection_slot.p && (!current || dirty[0] & /*value*/
        8 | dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            selection_slot,
            selection_slot_template,
            ctx,
            /*$$scope*/
            ctx[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[82]
            ) : get_slot_changes(
              selection_slot_template,
              /*$$scope*/
              ctx[82],
              dirty,
              get_selection_slot_changes
            ),
            get_selection_slot_context
          );
        }
      } else {
        if (selection_slot_or_fallback && selection_slot_or_fallback.p && (!current || dirty[0] & /*value, label*/
        4104)) {
          selection_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
        }
      }
      if (!/*disabled*/
      ctx[11] && !/*multiFullItemClearable*/
      ctx[10] && ClearIcon_default) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & /*disabled, multiFullItemClearable*/
          3072) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_6(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*activeValue*/
      67108864) {
        toggle_class(
          div,
          "active",
          /*activeValue*/
          ctx[26] === /*i*/
          ctx[128]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      2048) {
        toggle_class(
          div,
          "disabled",
          /*disabled*/
          ctx[11]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(selection_slot_or_fallback, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(selection_slot_or_fallback, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (selection_slot_or_fallback)
        selection_slot_or_fallback.d(detaching);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(749:16) {#each value as item, i}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let div;
  let current;
  const loading_icon_slot_template = (
    /*#slots*/
    ctx[83]["loading-icon"]
  );
  const loading_icon_slot = create_slot(
    loading_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_loading_icon_slot_context
  );
  const loading_icon_slot_or_fallback = loading_icon_slot || fallback_block_4(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (loading_icon_slot_or_fallback)
        loading_icon_slot_or_fallback.c();
      attr_dev(div, "class", "icon loading svelte-u3g5ju");
      attr_dev(div, "aria-hidden", "true");
      add_location(div, file4, 797, 12, 25521);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (loading_icon_slot_or_fallback) {
        loading_icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (loading_icon_slot) {
        if (loading_icon_slot.p && (!current || dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            loading_icon_slot,
            loading_icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              loading_icon_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_loading_icon_slot_changes
            ),
            get_loading_icon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(loading_icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loading_icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (loading_icon_slot_or_fallback)
        loading_icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(797:8) {#if loading}",
    ctx
  });
  return block;
}
function fallback_block_4(ctx) {
  let loadingicon;
  let current;
  loadingicon = new LoadingIcon_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(loadingicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(loadingicon, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(loadingicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loadingicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(loadingicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_4.name,
    type: "fallback",
    source: "(799:42)                      ",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const clear_icon_slot_template = (
    /*#slots*/
    ctx[83]["clear-icon"]
  );
  const clear_icon_slot = create_slot(
    clear_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_clear_icon_slot_context
  );
  const clear_icon_slot_or_fallback = clear_icon_slot || fallback_block_3(ctx);
  const block = {
    c: function create() {
      button = element("button");
      if (clear_icon_slot_or_fallback)
        clear_icon_slot_or_fallback.c();
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "icon clear-select svelte-u3g5ju");
      add_location(button, file4, 805, 12, 25740);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (clear_icon_slot_or_fallback) {
        clear_icon_slot_or_fallback.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*handleClear*/
          ctx[22],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (clear_icon_slot) {
        if (clear_icon_slot.p && (!current || dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            clear_icon_slot,
            clear_icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              clear_icon_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_clear_icon_slot_changes
            ),
            get_clear_icon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(clear_icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(clear_icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (clear_icon_slot_or_fallback)
        clear_icon_slot_or_fallback.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(805:8) {#if showClear}",
    ctx
  });
  return block;
}
function fallback_block_3(ctx) {
  let clearicon;
  let current;
  clearicon = new ClearIcon_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(clearicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(clearicon, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(clearicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(clearicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(clearicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_3.name,
    type: "fallback",
    source: "(807:40)                      ",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div;
  let current;
  const chevron_icon_slot_template = (
    /*#slots*/
    ctx[83]["chevron-icon"]
  );
  const chevron_icon_slot = create_slot(
    chevron_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_chevron_icon_slot_context
  );
  const chevron_icon_slot_or_fallback = chevron_icon_slot || fallback_block_2(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (chevron_icon_slot_or_fallback)
        chevron_icon_slot_or_fallback.c();
      attr_dev(div, "class", "icon chevron svelte-u3g5ju");
      attr_dev(div, "aria-hidden", "true");
      add_location(div, file4, 813, 12, 25986);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (chevron_icon_slot_or_fallback) {
        chevron_icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (chevron_icon_slot) {
        if (chevron_icon_slot.p && (!current || dirty[0] & /*listOpen*/
        64 | dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            chevron_icon_slot,
            chevron_icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              chevron_icon_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_chevron_icon_slot_changes
            ),
            get_chevron_icon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chevron_icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevron_icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (chevron_icon_slot_or_fallback)
        chevron_icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(813:8) {#if showChevron}",
    ctx
  });
  return block;
}
function fallback_block_2(ctx) {
  let chevronicon;
  let current;
  chevronicon = new ChevronIcon_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(chevronicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(chevronicon, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chevronicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevronicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(chevronicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_2.name,
    type: "fallback",
    source: "(815:53)                      ",
    ctx
  });
  return block;
}
function fallback_block_1(ctx) {
  let input_1;
  let input_1_value_value;
  const block = {
    c: function create() {
      input_1 = element("input");
      attr_dev(
        input_1,
        "name",
        /*name*/
        ctx[8]
      );
      attr_dev(input_1, "type", "hidden");
      input_1.value = input_1_value_value = /*value*/
      ctx[3] ? JSON.stringify(
        /*value*/
        ctx[3]
      ) : null;
      attr_dev(input_1, "class", "svelte-u3g5ju");
      add_location(input_1, file4, 822, 8, 26238);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input_1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*name*/
      256) {
        attr_dev(
          input_1,
          "name",
          /*name*/
          ctx2[8]
        );
      }
      if (dirty[0] & /*value*/
      8 && input_1_value_value !== (input_1_value_value = /*value*/
      ctx2[3] ? JSON.stringify(
        /*value*/
        ctx2[3]
      ) : null)) {
        prop_dev(input_1, "value", input_1_value_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(822:38)          ",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let current;
  const required_slot_template = (
    /*#slots*/
    ctx[83].required
  );
  const required_slot = create_slot(
    required_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_required_slot_context
  );
  const required_slot_or_fallback = required_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      if (required_slot_or_fallback)
        required_slot_or_fallback.c();
    },
    m: function mount(target, anchor) {
      if (required_slot_or_fallback) {
        required_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (required_slot) {
        if (required_slot.p && (!current || dirty[0] & /*value*/
        8 | dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            required_slot,
            required_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              required_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_required_slot_changes
            ),
            get_required_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(required_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(required_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (required_slot_or_fallback)
        required_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(826:4) {#if required && (!value || value.length === 0)}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let select;
  const block = {
    c: function create() {
      select = element("select");
      attr_dev(select, "class", "required svelte-u3g5ju");
      select.required = true;
      attr_dev(select, "tabindex", "-1");
      attr_dev(select, "aria-hidden", "true");
      add_location(select, file4, 827, 12, 26431);
    },
    m: function mount(target, anchor) {
      insert_dev(target, select, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(select);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(827:38)              ",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let div3;
  let t0;
  let span;
  let t1;
  let div0;
  let t2;
  let div1;
  let t3;
  let input_1;
  let input_1_readonly_value;
  let t4;
  let div2;
  let t5;
  let t6;
  let t7;
  let t8;
  let div3_class_value;
  let floatingRef_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*listOpen*/
    ctx[6] && create_if_block_8(ctx)
  );
  let if_block1 = (
    /*focused*/
    ctx[2] && create_if_block_7(ctx)
  );
  const prepend_slot_template = (
    /*#slots*/
    ctx[83].prepend
  );
  const prepend_slot = create_slot(
    prepend_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_prepend_slot_context
  );
  let if_block2 = (
    /*hasValue*/
    ctx[25] && create_if_block_4(ctx)
  );
  let input_1_levels = [
    {
      readOnly: input_1_readonly_value = !/*searchable*/
      ctx[17]
    },
    /*_inputAttributes*/
    ctx[27],
    { placeholder: (
      /*placeholderText*/
      ctx[33]
    ) },
    { style: (
      /*inputStyles*/
      ctx[18]
    ) },
    { disabled: (
      /*disabled*/
      ctx[11]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_1_levels.length; i += 1) {
    input_data = assign(input_data, input_1_levels[i]);
  }
  let if_block3 = (
    /*loading*/
    ctx[5] && create_if_block_3(ctx)
  );
  let if_block4 = (
    /*showClear*/
    ctx[34] && create_if_block_2(ctx)
  );
  let if_block5 = (
    /*showChevron*/
    ctx[20] && create_if_block_1(ctx)
  );
  const input_hidden_slot_template = (
    /*#slots*/
    ctx[83]["input-hidden"]
  );
  const input_hidden_slot = create_slot(
    input_hidden_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_input_hidden_slot_context
  );
  const input_hidden_slot_or_fallback = input_hidden_slot || fallback_block_1(ctx);
  let if_block6 = (
    /*required*/
    ctx[16] && (!/*value*/
    ctx[3] || /*value*/
    ctx[3].length === 0) && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      div3 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      span = element("span");
      if (if_block1)
        if_block1.c();
      t1 = space();
      div0 = element("div");
      if (prepend_slot)
        prepend_slot.c();
      t2 = space();
      div1 = element("div");
      if (if_block2)
        if_block2.c();
      t3 = space();
      input_1 = element("input");
      t4 = space();
      div2 = element("div");
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (if_block4)
        if_block4.c();
      t6 = space();
      if (if_block5)
        if_block5.c();
      t7 = space();
      if (input_hidden_slot_or_fallback)
        input_hidden_slot_or_fallback.c();
      t8 = space();
      if (if_block6)
        if_block6.c();
      attr_dev(span, "aria-live", "polite");
      attr_dev(span, "aria-atomic", "false");
      attr_dev(span, "aria-relevant", "additions text");
      attr_dev(span, "class", "a11y-text svelte-u3g5ju");
      add_location(span, file4, 732, 4, 23133);
      attr_dev(div0, "class", "prepend svelte-u3g5ju");
      add_location(div0, file4, 741, 4, 23429);
      set_attributes(input_1, input_data);
      toggle_class(input_1, "svelte-u3g5ju", true);
      add_location(input_1, file4, 782, 8, 25097);
      attr_dev(div1, "class", "value-container svelte-u3g5ju");
      add_location(div1, file4, 745, 4, 23499);
      attr_dev(div2, "class", "indicators svelte-u3g5ju");
      add_location(div2, file4, 795, 4, 25462);
      attr_dev(div3, "class", div3_class_value = "svelte-select " + /*containerClasses*/
      ctx[21] + " svelte-u3g5ju");
      attr_dev(
        div3,
        "style",
        /*containerStyles*/
        ctx[14]
      );
      attr_dev(div3, "role", "none");
      toggle_class(
        div3,
        "multi",
        /*multiple*/
        ctx[9]
      );
      toggle_class(
        div3,
        "disabled",
        /*disabled*/
        ctx[11]
      );
      toggle_class(
        div3,
        "focused",
        /*focused*/
        ctx[2]
      );
      toggle_class(
        div3,
        "list-open",
        /*listOpen*/
        ctx[6]
      );
      toggle_class(
        div3,
        "show-chevron",
        /*showChevron*/
        ctx[20]
      );
      toggle_class(
        div3,
        "error",
        /*hasError*/
        ctx[15]
      );
      add_location(div3, file4, 672, 0, 20633);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div3, anchor);
      if (if_block0)
        if_block0.m(div3, null);
      append_dev(div3, t0);
      append_dev(div3, span);
      if (if_block1)
        if_block1.m(span, null);
      append_dev(div3, t1);
      append_dev(div3, div0);
      if (prepend_slot) {
        prepend_slot.m(div0, null);
      }
      append_dev(div3, t2);
      append_dev(div3, div1);
      if (if_block2)
        if_block2.m(div1, null);
      append_dev(div1, t3);
      append_dev(div1, input_1);
      if (input_1.autofocus)
        input_1.focus();
      ctx[94](input_1);
      set_input_value(
        input_1,
        /*filterText*/
        ctx[4]
      );
      append_dev(div3, t4);
      append_dev(div3, div2);
      if (if_block3)
        if_block3.m(div2, null);
      append_dev(div2, t5);
      if (if_block4)
        if_block4.m(div2, null);
      append_dev(div2, t6);
      if (if_block5)
        if_block5.m(div2, null);
      append_dev(div3, t7);
      if (input_hidden_slot_or_fallback) {
        input_hidden_slot_or_fallback.m(div3, null);
      }
      append_dev(div3, t8);
      if (if_block6)
        if_block6.m(div3, null);
      ctx[96](div3);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "click",
            /*handleClickOutside*/
            ctx[42],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "keydown",
            /*handleKeyDown*/
            ctx[37],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input_1,
            "keydown",
            /*handleKeyDown*/
            ctx[37],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input_1,
            "blur",
            /*handleBlur*/
            ctx[39],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input_1,
            "focus",
            /*handleFocus*/
            ctx[38],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input_1,
            "input",
            /*input_1_input_handler*/
            ctx[95]
          ),
          listen_dev(div3, "pointerup", prevent_default(
            /*handleClick*/
            ctx[40]
          ), false, true, false, false),
          action_destroyer(floatingRef_action = /*floatingRef*/
          ctx[48].call(null, div3))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*listOpen*/
        ctx2[6]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*listOpen*/
          64) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_8(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div3, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*focused*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_7(ctx2);
          if_block1.c();
          if_block1.m(span, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (prepend_slot) {
        if (prepend_slot.p && (!current || dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            prepend_slot,
            prepend_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              prepend_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_prepend_slot_changes
            ),
            get_prepend_slot_context
          );
        }
      }
      if (
        /*hasValue*/
        ctx2[25]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*hasValue*/
          33554432) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_4(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      set_attributes(input_1, input_data = get_spread_update(input_1_levels, [
        (!current || dirty[0] & /*searchable*/
        131072 && input_1_readonly_value !== (input_1_readonly_value = !/*searchable*/
        ctx2[17])) && { readOnly: input_1_readonly_value },
        dirty[0] & /*_inputAttributes*/
        134217728 && /*_inputAttributes*/
        ctx2[27],
        (!current || dirty[1] & /*placeholderText*/
        4) && { placeholder: (
          /*placeholderText*/
          ctx2[33]
        ) },
        (!current || dirty[0] & /*inputStyles*/
        262144) && { style: (
          /*inputStyles*/
          ctx2[18]
        ) },
        (!current || dirty[0] & /*disabled*/
        2048) && { disabled: (
          /*disabled*/
          ctx2[11]
        ) }
      ]));
      if (dirty[0] & /*filterText*/
      16 && input_1.value !== /*filterText*/
      ctx2[4]) {
        set_input_value(
          input_1,
          /*filterText*/
          ctx2[4]
        );
      }
      toggle_class(input_1, "svelte-u3g5ju", true);
      if (
        /*loading*/
        ctx2[5]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*loading*/
          32) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_3(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div2, t5);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*showClear*/
        ctx2[34]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[1] & /*showClear*/
          8) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_2(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div2, t6);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*showChevron*/
        ctx2[20]
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*showChevron*/
          1048576) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_1(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(div2, null);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (input_hidden_slot) {
        if (input_hidden_slot.p && (!current || dirty[0] & /*value*/
        8 | dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            input_hidden_slot,
            input_hidden_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              input_hidden_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_input_hidden_slot_changes
            ),
            get_input_hidden_slot_context
          );
        }
      } else {
        if (input_hidden_slot_or_fallback && input_hidden_slot_or_fallback.p && (!current || dirty[0] & /*name, value*/
        264)) {
          input_hidden_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1, -1, -1] : dirty);
        }
      }
      if (
        /*required*/
        ctx2[16] && (!/*value*/
        ctx2[3] || /*value*/
        ctx2[3].length === 0)
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[0] & /*required, value*/
          65544) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(div3, null);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*containerClasses*/
      2097152 && div3_class_value !== (div3_class_value = "svelte-select " + /*containerClasses*/
      ctx2[21] + " svelte-u3g5ju")) {
        attr_dev(div3, "class", div3_class_value);
      }
      if (!current || dirty[0] & /*containerStyles*/
      16384) {
        attr_dev(
          div3,
          "style",
          /*containerStyles*/
          ctx2[14]
        );
      }
      if (!current || dirty[0] & /*containerClasses, multiple*/
      2097664) {
        toggle_class(
          div3,
          "multi",
          /*multiple*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*containerClasses, disabled*/
      2099200) {
        toggle_class(
          div3,
          "disabled",
          /*disabled*/
          ctx2[11]
        );
      }
      if (!current || dirty[0] & /*containerClasses, focused*/
      2097156) {
        toggle_class(
          div3,
          "focused",
          /*focused*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*containerClasses, listOpen*/
      2097216) {
        toggle_class(
          div3,
          "list-open",
          /*listOpen*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*containerClasses, showChevron*/
      3145728) {
        toggle_class(
          div3,
          "show-chevron",
          /*showChevron*/
          ctx2[20]
        );
      }
      if (!current || dirty[0] & /*containerClasses, hasError*/
      2129920) {
        toggle_class(
          div3,
          "error",
          /*hasError*/
          ctx2[15]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(prepend_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      transition_in(input_hidden_slot_or_fallback, local);
      transition_in(if_block6);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(prepend_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      transition_out(input_hidden_slot_or_fallback, local);
      transition_out(if_block6);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (prepend_slot)
        prepend_slot.d(detaching);
      if (if_block2)
        if_block2.d();
      ctx[94](null);
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      if (input_hidden_slot_or_fallback)
        input_hidden_slot_or_fallback.d(detaching);
      if (if_block6)
        if_block6.d();
      ctx[96](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function convertStringItemsToObjects(_items) {
  return _items.map((item, index) => {
    return { index, value: item, label: `${item}` };
  });
}
function isItemFirst(itemIndex) {
  return itemIndex === 0;
}
function isItemSelectable(item) {
  return item.groupHeader && item.selectable || item.selectable || !item.hasOwnProperty("selectable");
}
function instance4($$self, $$props, $$invalidate) {
  let hasValue;
  let hideSelectedItem;
  let showClear;
  let placeholderText;
  let ariaSelection;
  let ariaContext;
  let filteredItems;
  let listDom;
  let scrollToHoverItem;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Select", slots, [
    "list-prepend",
    "list",
    "item",
    "empty",
    "list-append",
    "prepend",
    "selection",
    "multi-clear-icon",
    "loading-icon",
    "clear-icon",
    "chevron-icon",
    "input-hidden",
    "required"
  ]);
  const $$slots = compute_slots(slots);
  const dispatch = createEventDispatcher();
  let { justValue = null } = $$props;
  let { filter: filter2 = filter } = $$props;
  let { getItems: getItems2 = getItems } = $$props;
  let { id = null } = $$props;
  let { name = null } = $$props;
  let { container = void 0 } = $$props;
  let { input = void 0 } = $$props;
  let { multiple = false } = $$props;
  let { multiFullItemClearable = false } = $$props;
  let { disabled = false } = $$props;
  let { focused = false } = $$props;
  let { value = null } = $$props;
  let { filterText = "" } = $$props;
  let { placeholder = "Please select" } = $$props;
  let { placeholderAlwaysShow = false } = $$props;
  let { items = null } = $$props;
  let { label = "label" } = $$props;
  let { itemFilter = (label2, filterText2, option) => `${label2}`.toLowerCase().includes(filterText2.toLowerCase()) } = $$props;
  let { groupBy = void 0 } = $$props;
  let { groupFilter = (groups) => groups } = $$props;
  let { groupHeaderSelectable = false } = $$props;
  let { itemId = "value" } = $$props;
  let { loadOptions = void 0 } = $$props;
  let { containerStyles = "" } = $$props;
  let { hasError = false } = $$props;
  let { filterSelectedItems = true } = $$props;
  let { required = false } = $$props;
  let { closeListOnChange = true } = $$props;
  let { clearFilterTextOnBlur = true } = $$props;
  let { createGroupHeaderItem = (groupValue, item) => {
    return { value: groupValue, [label]: groupValue };
  } } = $$props;
  const getFilteredItems = () => {
    return filteredItems;
  };
  let { searchable = true } = $$props;
  let { inputStyles = "" } = $$props;
  let { clearable = true } = $$props;
  let { loading = false } = $$props;
  let { listOpen = false } = $$props;
  let timeout;
  let { debounce = (fn, wait = 1) => {
    clearTimeout(timeout);
    timeout = setTimeout(fn, wait);
  } } = $$props;
  let { debounceWait = 300 } = $$props;
  let { hideEmptyState = false } = $$props;
  let { inputAttributes = {} } = $$props;
  let { listAutoWidth = true } = $$props;
  let { showChevron = false } = $$props;
  let { listOffset = 5 } = $$props;
  let { hoverItemIndex = 0 } = $$props;
  let { floatingConfig = {} } = $$props;
  let { class: containerClasses = "" } = $$props;
  let activeValue;
  let prev_value;
  let prev_filterText;
  let prev_multiple;
  function setValue() {
    if (typeof value === "string") {
      let item = (items || []).find((item2) => item2[itemId] === value);
      $$invalidate(3, value = item || { [itemId]: value, label: value });
    } else if (multiple && Array.isArray(value) && value.length > 0) {
      $$invalidate(3, value = value.map((item) => typeof item === "string" ? { value: item, label: item } : item));
    }
  }
  let _inputAttributes;
  function assignInputAttributes() {
    $$invalidate(27, _inputAttributes = Object.assign(
      {
        autocapitalize: "none",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: false,
        tabindex: 0,
        type: "text",
        "aria-autocomplete": "list"
      },
      inputAttributes
    ));
    if (id) {
      $$invalidate(27, _inputAttributes["id"] = id, _inputAttributes);
    }
    if (!searchable) {
      $$invalidate(27, _inputAttributes["readonly"] = true, _inputAttributes);
    }
  }
  function filterGroupedItems(_items) {
    const groupValues = [];
    const groups = {};
    _items.forEach((item) => {
      const groupValue = groupBy(item);
      if (!groupValues.includes(groupValue)) {
        groupValues.push(groupValue);
        groups[groupValue] = [];
        if (groupValue) {
          groups[groupValue].push(Object.assign(createGroupHeaderItem(groupValue, item), {
            id: groupValue,
            groupHeader: true,
            selectable: groupHeaderSelectable
          }));
        }
      }
      groups[groupValue].push(Object.assign({ groupItem: !!groupValue }, item));
    });
    const sortedGroupedItems = [];
    groupFilter(groupValues).forEach((groupValue) => {
      if (groups[groupValue])
        sortedGroupedItems.push(...groups[groupValue]);
    });
    return sortedGroupedItems;
  }
  function dispatchSelectedItem() {
    if (multiple) {
      if (JSON.stringify(value) !== JSON.stringify(prev_value)) {
        if (checkValueForDuplicates()) {
          dispatch("input", value);
        }
      }
      return;
    }
    if (!prev_value || JSON.stringify(value[itemId]) !== JSON.stringify(prev_value[itemId])) {
      dispatch("input", value);
    }
  }
  function setupMulti() {
    if (value) {
      if (Array.isArray(value)) {
        $$invalidate(3, value = [...value]);
      } else {
        $$invalidate(3, value = [value]);
      }
    }
  }
  function setupSingle() {
    if (value)
      $$invalidate(3, value = null);
  }
  function setValueIndexAsHoverIndex() {
    const valueIndex = filteredItems.findIndex((i) => {
      return i[itemId] === value[itemId];
    });
    checkHoverSelectable(valueIndex, true);
  }
  function dispatchHover(i) {
    dispatch("hoverItem", i);
  }
  function checkHoverSelectable(startingIndex = 0, ignoreGroup) {
    $$invalidate(7, hoverItemIndex = startingIndex < 0 ? 0 : startingIndex);
    if (!ignoreGroup && groupBy && filteredItems[hoverItemIndex] && !filteredItems[hoverItemIndex].selectable) {
      setHoverIndex(1);
    }
  }
  function setupFilterText() {
    if (!loadOptions && filterText.length === 0)
      return;
    if (loadOptions) {
      debounce(
        async function() {
          $$invalidate(5, loading = true);
          let res = await getItems2({
            dispatch,
            loadOptions,
            convertStringItemsToObjects,
            filterText
          });
          if (res) {
            $$invalidate(5, loading = res.loading);
            $$invalidate(6, listOpen = listOpen ? res.listOpen : filterText.length > 0 ? true : false);
            $$invalidate(2, focused = listOpen && res.focused);
            $$invalidate(51, items = groupBy ? filterGroupedItems(res.filteredItems) : res.filteredItems);
          } else {
            $$invalidate(5, loading = false);
            $$invalidate(2, focused = true);
            $$invalidate(6, listOpen = true);
          }
        },
        debounceWait
      );
    } else {
      $$invalidate(6, listOpen = true);
      if (multiple) {
        $$invalidate(26, activeValue = void 0);
      }
    }
  }
  function handleFilterEvent(items2) {
    if (listOpen)
      dispatch("filter", items2);
  }
  beforeUpdate(async () => {
    $$invalidate(78, prev_value = value);
    $$invalidate(79, prev_filterText = filterText);
    $$invalidate(80, prev_multiple = multiple);
  });
  function computeJustValue() {
    if (multiple)
      return value ? value.map((item) => item[itemId]) : null;
    return value ? value[itemId] : value;
  }
  function checkValueForDuplicates() {
    let noDuplicates = true;
    if (value) {
      const ids = [];
      const uniqueValues = [];
      value.forEach((val) => {
        if (!ids.includes(val[itemId])) {
          ids.push(val[itemId]);
          uniqueValues.push(val);
        } else {
          noDuplicates = false;
        }
      });
      if (!noDuplicates)
        $$invalidate(3, value = uniqueValues);
    }
    return noDuplicates;
  }
  function findItem(selection) {
    let matchTo = selection ? selection[itemId] : value[itemId];
    return items.find((item) => item[itemId] === matchTo);
  }
  function updateValueDisplay(items2) {
    if (!items2 || items2.length === 0 || items2.some((item) => typeof item !== "object"))
      return;
    if (!value || (multiple ? value.some((selection) => !selection || !selection[itemId]) : !value[itemId]))
      return;
    if (Array.isArray(value)) {
      $$invalidate(3, value = value.map((selection) => findItem(selection) || selection));
    } else {
      $$invalidate(3, value = findItem() || value);
    }
  }
  async function handleMultiItemClear(i) {
    const itemToRemove = value[i];
    if (value.length === 1) {
      $$invalidate(3, value = void 0);
    } else {
      $$invalidate(3, value = value.filter((item) => {
        return item !== itemToRemove;
      }));
    }
    dispatch("clear", itemToRemove);
  }
  function handleKeyDown(e) {
    if (!focused)
      return;
    e.stopPropagation();
    switch (e.key) {
      case "Escape":
        e.preventDefault();
        closeList();
        break;
      case "Enter":
        e.preventDefault();
        if (listOpen) {
          if (filteredItems.length === 0)
            break;
          const hoverItem = filteredItems[hoverItemIndex];
          if (value && !multiple && value[itemId] === hoverItem[itemId]) {
            closeList();
            break;
          } else {
            handleSelect(filteredItems[hoverItemIndex]);
          }
        }
        break;
      case "ArrowDown":
        e.preventDefault();
        if (listOpen) {
          setHoverIndex(1);
        } else {
          $$invalidate(6, listOpen = true);
          $$invalidate(26, activeValue = void 0);
        }
        break;
      case "ArrowUp":
        e.preventDefault();
        if (listOpen) {
          setHoverIndex(-1);
        } else {
          $$invalidate(6, listOpen = true);
          $$invalidate(26, activeValue = void 0);
        }
        break;
      case "Tab":
        if (listOpen && focused) {
          if (filteredItems.length === 0 || value && value[itemId] === filteredItems[hoverItemIndex][itemId])
            return closeList();
          e.preventDefault();
          handleSelect(filteredItems[hoverItemIndex]);
          closeList();
        }
        break;
      case "Backspace":
        if (!multiple || filterText.length > 0)
          return;
        if (multiple && value && value.length > 0) {
          handleMultiItemClear(activeValue !== void 0 ? activeValue : value.length - 1);
          if (activeValue === 0 || activeValue === void 0)
            break;
          $$invalidate(26, activeValue = value.length > activeValue ? activeValue - 1 : void 0);
        }
        break;
      case "ArrowLeft":
        if (!value || !multiple || filterText.length > 0)
          return;
        if (activeValue === void 0) {
          $$invalidate(26, activeValue = value.length - 1);
        } else if (value.length > activeValue && activeValue !== 0) {
          $$invalidate(26, activeValue -= 1);
        }
        break;
      case "ArrowRight":
        if (!value || !multiple || filterText.length > 0 || activeValue === void 0)
          return;
        if (activeValue === value.length - 1) {
          $$invalidate(26, activeValue = void 0);
        } else if (activeValue < value.length - 1) {
          $$invalidate(26, activeValue += 1);
        }
        break;
    }
  }
  function handleFocus(e) {
    if (focused && input === (document == null ? void 0 : document.activeElement))
      return;
    if (e)
      dispatch("focus", e);
    input == null ? void 0 : input.focus();
    $$invalidate(2, focused = true);
  }
  async function handleBlur(e) {
    if (isScrolling)
      return;
    if (listOpen || focused) {
      dispatch("blur", e);
      closeList();
      $$invalidate(2, focused = false);
      $$invalidate(26, activeValue = void 0);
      input == null ? void 0 : input.blur();
    }
  }
  function handleClick() {
    if (disabled)
      return;
    if (filterText.length > 0)
      return $$invalidate(6, listOpen = true);
    $$invalidate(6, listOpen = !listOpen);
  }
  function handleClear() {
    dispatch("clear", value);
    $$invalidate(3, value = void 0);
    closeList();
    handleFocus();
  }
  onMount(() => {
    if (listOpen)
      $$invalidate(2, focused = true);
    if (focused && input)
      input.focus();
  });
  function itemSelected(selection) {
    if (selection) {
      $$invalidate(4, filterText = "");
      const item = Object.assign({}, selection);
      if (item.groupHeader && !item.selectable)
        return;
      $$invalidate(3, value = multiple ? value ? value.concat([item]) : [item] : $$invalidate(3, value = item));
      setTimeout(() => {
        if (closeListOnChange)
          closeList();
        $$invalidate(26, activeValue = void 0);
        dispatch("change", value);
        dispatch("select", selection);
      });
    }
  }
  function closeList() {
    if (clearFilterTextOnBlur) {
      $$invalidate(4, filterText = "");
    }
    $$invalidate(6, listOpen = false);
  }
  let { ariaValues = (values) => {
    return `Option ${values}, selected.`;
  } } = $$props;
  let { ariaListOpen = (label2, count) => {
    return `You are currently focused on option ${label2}. There are ${count} results available.`;
  } } = $$props;
  let { ariaFocused = () => {
    return `Select is focused, type to refine list, press down to open the menu.`;
  } } = $$props;
  function handleAriaSelection(_multiple) {
    let selected = void 0;
    if (_multiple && value.length > 0) {
      selected = value.map((v) => v[label]).join(", ");
    } else {
      selected = value[label];
    }
    return ariaValues(selected);
  }
  function handleAriaContent() {
    if (!filteredItems || filteredItems.length === 0)
      return "";
    let _item = filteredItems[hoverItemIndex];
    if (listOpen && _item) {
      let count = filteredItems ? filteredItems.length : 0;
      return ariaListOpen(_item[label], count);
    } else {
      return ariaFocused();
    }
  }
  let list = null;
  let isScrollingTimer;
  function handleListScroll() {
    clearTimeout(isScrollingTimer);
    isScrollingTimer = setTimeout(
      () => {
        isScrolling = false;
      },
      100
    );
  }
  function handleClickOutside(event) {
    if (!listOpen && !focused && container && !container.contains(event.target) && !(list == null ? void 0 : list.contains(event.target))) {
      handleBlur();
    }
  }
  onDestroy(() => {
    list == null ? void 0 : list.remove();
  });
  let isScrolling = false;
  function handleSelect(item) {
    if (!item || item.selectable === false)
      return;
    itemSelected(item);
  }
  function handleHover(i) {
    if (isScrolling)
      return;
    $$invalidate(7, hoverItemIndex = i);
  }
  function handleItemClick(args) {
    const { item, i } = args;
    if ((item == null ? void 0 : item.selectable) === false)
      return;
    if (value && !multiple && value[itemId] === item[itemId])
      return closeList();
    if (isItemSelectable(item)) {
      $$invalidate(7, hoverItemIndex = i);
      handleSelect(item);
    }
  }
  function setHoverIndex(increment) {
    let selectableFilteredItems = filteredItems.filter((item) => !Object.hasOwn(item, "selectable") || item.selectable === true);
    if (selectableFilteredItems.length === 0) {
      return $$invalidate(7, hoverItemIndex = 0);
    }
    if (increment > 0 && hoverItemIndex === filteredItems.length - 1) {
      $$invalidate(7, hoverItemIndex = 0);
    } else if (increment < 0 && hoverItemIndex === 0) {
      $$invalidate(7, hoverItemIndex = filteredItems.length - 1);
    } else {
      $$invalidate(7, hoverItemIndex = hoverItemIndex + increment);
    }
    const hover = filteredItems[hoverItemIndex];
    if (hover && hover.selectable === false) {
      if (increment === 1 || increment === -1)
        setHoverIndex(increment);
      return;
    }
  }
  function isItemActive(item, value2, itemId2) {
    if (multiple)
      return;
    return value2 && value2[itemId2] === item[itemId2];
  }
  const activeScroll = scrollAction;
  const hoverScroll = scrollAction;
  function scrollAction(node) {
    return {
      update(args) {
        if (args.scroll) {
          handleListScroll();
          node.scrollIntoView({ behavior: "auto", block: "nearest" });
        }
      }
    };
  }
  function setListWidth() {
    const { width } = container.getBoundingClientRect();
    $$invalidate(23, list.style.width = listAutoWidth ? width + "px" : "auto", list);
  }
  let _floatingConfig = {
    strategy: "absolute",
    placement: "bottom-start",
    middleware: [offset(listOffset), flip2(), shift2()],
    autoUpdate: false
  };
  const [floatingRef, floatingContent, floatingUpdate] = createFloatingActions(_floatingConfig);
  let prefloat = true;
  function listMounted(list2, listOpen2) {
    if (!list2 || !listOpen2)
      return $$invalidate(28, prefloat = true);
    setTimeout(
      () => {
        $$invalidate(28, prefloat = false);
      },
      0
    );
  }
  const writable_props = [
    "justValue",
    "filter",
    "getItems",
    "id",
    "name",
    "container",
    "input",
    "multiple",
    "multiFullItemClearable",
    "disabled",
    "focused",
    "value",
    "filterText",
    "placeholder",
    "placeholderAlwaysShow",
    "items",
    "label",
    "itemFilter",
    "groupBy",
    "groupFilter",
    "groupHeaderSelectable",
    "itemId",
    "loadOptions",
    "containerStyles",
    "hasError",
    "filterSelectedItems",
    "required",
    "closeListOnChange",
    "clearFilterTextOnBlur",
    "createGroupHeaderItem",
    "searchable",
    "inputStyles",
    "clearable",
    "loading",
    "listOpen",
    "debounce",
    "debounceWait",
    "hideEmptyState",
    "inputAttributes",
    "listAutoWidth",
    "showChevron",
    "listOffset",
    "hoverItemIndex",
    "floatingConfig",
    "class",
    "ariaValues",
    "ariaListOpen",
    "ariaFocused"
  ];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Select> was created with unknown prop '${key}'`);
  });
  function keydown_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  const mouseover_handler = (i) => handleHover(i);
  const focus_handler = (i) => handleHover(i);
  const click_handler = (item, i) => handleItemClick({ item, i });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      list = $$value;
      $$invalidate(23, list);
    });
  }
  const pointerup_handler_1 = (i) => handleMultiItemClear(i);
  const click_handler_1 = (i) => multiFullItemClearable ? handleMultiItemClear(i) : {};
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(1, input);
    });
  }
  function input_1_input_handler() {
    filterText = this.value;
    $$invalidate(4, filterText);
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(0, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("justValue" in $$props2)
      $$invalidate(52, justValue = $$props2.justValue);
    if ("filter" in $$props2)
      $$invalidate(53, filter2 = $$props2.filter);
    if ("getItems" in $$props2)
      $$invalidate(54, getItems2 = $$props2.getItems);
    if ("id" in $$props2)
      $$invalidate(55, id = $$props2.id);
    if ("name" in $$props2)
      $$invalidate(8, name = $$props2.name);
    if ("container" in $$props2)
      $$invalidate(0, container = $$props2.container);
    if ("input" in $$props2)
      $$invalidate(1, input = $$props2.input);
    if ("multiple" in $$props2)
      $$invalidate(9, multiple = $$props2.multiple);
    if ("multiFullItemClearable" in $$props2)
      $$invalidate(10, multiFullItemClearable = $$props2.multiFullItemClearable);
    if ("disabled" in $$props2)
      $$invalidate(11, disabled = $$props2.disabled);
    if ("focused" in $$props2)
      $$invalidate(2, focused = $$props2.focused);
    if ("value" in $$props2)
      $$invalidate(3, value = $$props2.value);
    if ("filterText" in $$props2)
      $$invalidate(4, filterText = $$props2.filterText);
    if ("placeholder" in $$props2)
      $$invalidate(56, placeholder = $$props2.placeholder);
    if ("placeholderAlwaysShow" in $$props2)
      $$invalidate(57, placeholderAlwaysShow = $$props2.placeholderAlwaysShow);
    if ("items" in $$props2)
      $$invalidate(51, items = $$props2.items);
    if ("label" in $$props2)
      $$invalidate(12, label = $$props2.label);
    if ("itemFilter" in $$props2)
      $$invalidate(58, itemFilter = $$props2.itemFilter);
    if ("groupBy" in $$props2)
      $$invalidate(59, groupBy = $$props2.groupBy);
    if ("groupFilter" in $$props2)
      $$invalidate(60, groupFilter = $$props2.groupFilter);
    if ("groupHeaderSelectable" in $$props2)
      $$invalidate(61, groupHeaderSelectable = $$props2.groupHeaderSelectable);
    if ("itemId" in $$props2)
      $$invalidate(13, itemId = $$props2.itemId);
    if ("loadOptions" in $$props2)
      $$invalidate(62, loadOptions = $$props2.loadOptions);
    if ("containerStyles" in $$props2)
      $$invalidate(14, containerStyles = $$props2.containerStyles);
    if ("hasError" in $$props2)
      $$invalidate(15, hasError = $$props2.hasError);
    if ("filterSelectedItems" in $$props2)
      $$invalidate(63, filterSelectedItems = $$props2.filterSelectedItems);
    if ("required" in $$props2)
      $$invalidate(16, required = $$props2.required);
    if ("closeListOnChange" in $$props2)
      $$invalidate(64, closeListOnChange = $$props2.closeListOnChange);
    if ("clearFilterTextOnBlur" in $$props2)
      $$invalidate(65, clearFilterTextOnBlur = $$props2.clearFilterTextOnBlur);
    if ("createGroupHeaderItem" in $$props2)
      $$invalidate(66, createGroupHeaderItem = $$props2.createGroupHeaderItem);
    if ("searchable" in $$props2)
      $$invalidate(17, searchable = $$props2.searchable);
    if ("inputStyles" in $$props2)
      $$invalidate(18, inputStyles = $$props2.inputStyles);
    if ("clearable" in $$props2)
      $$invalidate(68, clearable = $$props2.clearable);
    if ("loading" in $$props2)
      $$invalidate(5, loading = $$props2.loading);
    if ("listOpen" in $$props2)
      $$invalidate(6, listOpen = $$props2.listOpen);
    if ("debounce" in $$props2)
      $$invalidate(69, debounce = $$props2.debounce);
    if ("debounceWait" in $$props2)
      $$invalidate(70, debounceWait = $$props2.debounceWait);
    if ("hideEmptyState" in $$props2)
      $$invalidate(19, hideEmptyState = $$props2.hideEmptyState);
    if ("inputAttributes" in $$props2)
      $$invalidate(71, inputAttributes = $$props2.inputAttributes);
    if ("listAutoWidth" in $$props2)
      $$invalidate(72, listAutoWidth = $$props2.listAutoWidth);
    if ("showChevron" in $$props2)
      $$invalidate(20, showChevron = $$props2.showChevron);
    if ("listOffset" in $$props2)
      $$invalidate(73, listOffset = $$props2.listOffset);
    if ("hoverItemIndex" in $$props2)
      $$invalidate(7, hoverItemIndex = $$props2.hoverItemIndex);
    if ("floatingConfig" in $$props2)
      $$invalidate(74, floatingConfig = $$props2.floatingConfig);
    if ("class" in $$props2)
      $$invalidate(21, containerClasses = $$props2.class);
    if ("ariaValues" in $$props2)
      $$invalidate(75, ariaValues = $$props2.ariaValues);
    if ("ariaListOpen" in $$props2)
      $$invalidate(76, ariaListOpen = $$props2.ariaListOpen);
    if ("ariaFocused" in $$props2)
      $$invalidate(77, ariaFocused = $$props2.ariaFocused);
    if ("$$scope" in $$props2)
      $$invalidate(82, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    beforeUpdate,
    createEventDispatcher,
    onDestroy,
    onMount,
    offset,
    flip: flip2,
    shift: shift2,
    createFloatingActions,
    dispatch,
    _filter: filter,
    _getItems: getItems,
    ChevronIcon: ChevronIcon_default,
    ClearIcon: ClearIcon_default,
    LoadingIcon: LoadingIcon_default,
    justValue,
    filter: filter2,
    getItems: getItems2,
    id,
    name,
    container,
    input,
    multiple,
    multiFullItemClearable,
    disabled,
    focused,
    value,
    filterText,
    placeholder,
    placeholderAlwaysShow,
    items,
    label,
    itemFilter,
    groupBy,
    groupFilter,
    groupHeaderSelectable,
    itemId,
    loadOptions,
    containerStyles,
    hasError,
    filterSelectedItems,
    required,
    closeListOnChange,
    clearFilterTextOnBlur,
    createGroupHeaderItem,
    getFilteredItems,
    searchable,
    inputStyles,
    clearable,
    loading,
    listOpen,
    timeout,
    debounce,
    debounceWait,
    hideEmptyState,
    inputAttributes,
    listAutoWidth,
    showChevron,
    listOffset,
    hoverItemIndex,
    floatingConfig,
    containerClasses,
    activeValue,
    prev_value,
    prev_filterText,
    prev_multiple,
    setValue,
    _inputAttributes,
    assignInputAttributes,
    convertStringItemsToObjects,
    filterGroupedItems,
    dispatchSelectedItem,
    setupMulti,
    setupSingle,
    setValueIndexAsHoverIndex,
    dispatchHover,
    checkHoverSelectable,
    setupFilterText,
    handleFilterEvent,
    computeJustValue,
    checkValueForDuplicates,
    findItem,
    updateValueDisplay,
    handleMultiItemClear,
    handleKeyDown,
    handleFocus,
    handleBlur,
    handleClick,
    handleClear,
    itemSelected,
    closeList,
    ariaValues,
    ariaListOpen,
    ariaFocused,
    handleAriaSelection,
    handleAriaContent,
    list,
    isScrollingTimer,
    handleListScroll,
    handleClickOutside,
    isScrolling,
    handleSelect,
    handleHover,
    handleItemClick,
    setHoverIndex,
    isItemActive,
    isItemFirst,
    isItemSelectable,
    activeScroll,
    hoverScroll,
    scrollAction,
    setListWidth,
    _floatingConfig,
    floatingRef,
    floatingContent,
    floatingUpdate,
    prefloat,
    listMounted,
    filteredItems,
    scrollToHoverItem,
    listDom,
    ariaContext,
    ariaSelection,
    placeholderText,
    hasValue,
    showClear,
    hideSelectedItem
  });
  $$self.$inject_state = ($$props2) => {
    if ("justValue" in $$props2)
      $$invalidate(52, justValue = $$props2.justValue);
    if ("filter" in $$props2)
      $$invalidate(53, filter2 = $$props2.filter);
    if ("getItems" in $$props2)
      $$invalidate(54, getItems2 = $$props2.getItems);
    if ("id" in $$props2)
      $$invalidate(55, id = $$props2.id);
    if ("name" in $$props2)
      $$invalidate(8, name = $$props2.name);
    if ("container" in $$props2)
      $$invalidate(0, container = $$props2.container);
    if ("input" in $$props2)
      $$invalidate(1, input = $$props2.input);
    if ("multiple" in $$props2)
      $$invalidate(9, multiple = $$props2.multiple);
    if ("multiFullItemClearable" in $$props2)
      $$invalidate(10, multiFullItemClearable = $$props2.multiFullItemClearable);
    if ("disabled" in $$props2)
      $$invalidate(11, disabled = $$props2.disabled);
    if ("focused" in $$props2)
      $$invalidate(2, focused = $$props2.focused);
    if ("value" in $$props2)
      $$invalidate(3, value = $$props2.value);
    if ("filterText" in $$props2)
      $$invalidate(4, filterText = $$props2.filterText);
    if ("placeholder" in $$props2)
      $$invalidate(56, placeholder = $$props2.placeholder);
    if ("placeholderAlwaysShow" in $$props2)
      $$invalidate(57, placeholderAlwaysShow = $$props2.placeholderAlwaysShow);
    if ("items" in $$props2)
      $$invalidate(51, items = $$props2.items);
    if ("label" in $$props2)
      $$invalidate(12, label = $$props2.label);
    if ("itemFilter" in $$props2)
      $$invalidate(58, itemFilter = $$props2.itemFilter);
    if ("groupBy" in $$props2)
      $$invalidate(59, groupBy = $$props2.groupBy);
    if ("groupFilter" in $$props2)
      $$invalidate(60, groupFilter = $$props2.groupFilter);
    if ("groupHeaderSelectable" in $$props2)
      $$invalidate(61, groupHeaderSelectable = $$props2.groupHeaderSelectable);
    if ("itemId" in $$props2)
      $$invalidate(13, itemId = $$props2.itemId);
    if ("loadOptions" in $$props2)
      $$invalidate(62, loadOptions = $$props2.loadOptions);
    if ("containerStyles" in $$props2)
      $$invalidate(14, containerStyles = $$props2.containerStyles);
    if ("hasError" in $$props2)
      $$invalidate(15, hasError = $$props2.hasError);
    if ("filterSelectedItems" in $$props2)
      $$invalidate(63, filterSelectedItems = $$props2.filterSelectedItems);
    if ("required" in $$props2)
      $$invalidate(16, required = $$props2.required);
    if ("closeListOnChange" in $$props2)
      $$invalidate(64, closeListOnChange = $$props2.closeListOnChange);
    if ("clearFilterTextOnBlur" in $$props2)
      $$invalidate(65, clearFilterTextOnBlur = $$props2.clearFilterTextOnBlur);
    if ("createGroupHeaderItem" in $$props2)
      $$invalidate(66, createGroupHeaderItem = $$props2.createGroupHeaderItem);
    if ("searchable" in $$props2)
      $$invalidate(17, searchable = $$props2.searchable);
    if ("inputStyles" in $$props2)
      $$invalidate(18, inputStyles = $$props2.inputStyles);
    if ("clearable" in $$props2)
      $$invalidate(68, clearable = $$props2.clearable);
    if ("loading" in $$props2)
      $$invalidate(5, loading = $$props2.loading);
    if ("listOpen" in $$props2)
      $$invalidate(6, listOpen = $$props2.listOpen);
    if ("timeout" in $$props2)
      timeout = $$props2.timeout;
    if ("debounce" in $$props2)
      $$invalidate(69, debounce = $$props2.debounce);
    if ("debounceWait" in $$props2)
      $$invalidate(70, debounceWait = $$props2.debounceWait);
    if ("hideEmptyState" in $$props2)
      $$invalidate(19, hideEmptyState = $$props2.hideEmptyState);
    if ("inputAttributes" in $$props2)
      $$invalidate(71, inputAttributes = $$props2.inputAttributes);
    if ("listAutoWidth" in $$props2)
      $$invalidate(72, listAutoWidth = $$props2.listAutoWidth);
    if ("showChevron" in $$props2)
      $$invalidate(20, showChevron = $$props2.showChevron);
    if ("listOffset" in $$props2)
      $$invalidate(73, listOffset = $$props2.listOffset);
    if ("hoverItemIndex" in $$props2)
      $$invalidate(7, hoverItemIndex = $$props2.hoverItemIndex);
    if ("floatingConfig" in $$props2)
      $$invalidate(74, floatingConfig = $$props2.floatingConfig);
    if ("containerClasses" in $$props2)
      $$invalidate(21, containerClasses = $$props2.containerClasses);
    if ("activeValue" in $$props2)
      $$invalidate(26, activeValue = $$props2.activeValue);
    if ("prev_value" in $$props2)
      $$invalidate(78, prev_value = $$props2.prev_value);
    if ("prev_filterText" in $$props2)
      $$invalidate(79, prev_filterText = $$props2.prev_filterText);
    if ("prev_multiple" in $$props2)
      $$invalidate(80, prev_multiple = $$props2.prev_multiple);
    if ("_inputAttributes" in $$props2)
      $$invalidate(27, _inputAttributes = $$props2._inputAttributes);
    if ("ariaValues" in $$props2)
      $$invalidate(75, ariaValues = $$props2.ariaValues);
    if ("ariaListOpen" in $$props2)
      $$invalidate(76, ariaListOpen = $$props2.ariaListOpen);
    if ("ariaFocused" in $$props2)
      $$invalidate(77, ariaFocused = $$props2.ariaFocused);
    if ("list" in $$props2)
      $$invalidate(23, list = $$props2.list);
    if ("isScrollingTimer" in $$props2)
      isScrollingTimer = $$props2.isScrollingTimer;
    if ("isScrolling" in $$props2)
      isScrolling = $$props2.isScrolling;
    if ("_floatingConfig" in $$props2)
      $$invalidate(81, _floatingConfig = $$props2._floatingConfig);
    if ("prefloat" in $$props2)
      $$invalidate(28, prefloat = $$props2.prefloat);
    if ("filteredItems" in $$props2)
      $$invalidate(24, filteredItems = $$props2.filteredItems);
    if ("scrollToHoverItem" in $$props2)
      $$invalidate(29, scrollToHoverItem = $$props2.scrollToHoverItem);
    if ("listDom" in $$props2)
      $$invalidate(30, listDom = $$props2.listDom);
    if ("ariaContext" in $$props2)
      $$invalidate(31, ariaContext = $$props2.ariaContext);
    if ("ariaSelection" in $$props2)
      $$invalidate(32, ariaSelection = $$props2.ariaSelection);
    if ("placeholderText" in $$props2)
      $$invalidate(33, placeholderText = $$props2.placeholderText);
    if ("hasValue" in $$props2)
      $$invalidate(25, hasValue = $$props2.hasValue);
    if ("showClear" in $$props2)
      $$invalidate(34, showClear = $$props2.showClear);
    if ("hideSelectedItem" in $$props2)
      $$invalidate(35, hideSelectedItem = $$props2.hideSelectedItem);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*value*/
    8 | $$self.$$.dirty[1] & /*items*/
    1048576) {
      $:
        if (items, value)
          setValue();
    }
    if ($$self.$$.dirty[0] & /*searchable*/
    131072 | $$self.$$.dirty[2] & /*inputAttributes*/
    512) {
      $:
        if (inputAttributes || !searchable)
          assignInputAttributes();
    }
    if ($$self.$$.dirty[0] & /*multiple*/
    512) {
      $:
        if (multiple)
          setupMulti();
    }
    if ($$self.$$.dirty[0] & /*multiple*/
    512 | $$self.$$.dirty[2] & /*prev_multiple*/
    262144) {
      $:
        if (prev_multiple && !multiple)
          setupSingle();
    }
    if ($$self.$$.dirty[0] & /*multiple, value*/
    520) {
      $:
        if (multiple && value && value.length > 1)
          checkValueForDuplicates();
    }
    if ($$self.$$.dirty[0] & /*value*/
    8) {
      $:
        if (value)
          dispatchSelectedItem();
    }
    if ($$self.$$.dirty[0] & /*value, multiple*/
    520 | $$self.$$.dirty[2] & /*prev_value*/
    65536) {
      $:
        if (!value && multiple && prev_value)
          dispatch("input", value);
    }
    if ($$self.$$.dirty[0] & /*focused, input*/
    6) {
      $:
        if (!focused && input)
          closeList();
    }
    if ($$self.$$.dirty[0] & /*filterText*/
    16 | $$self.$$.dirty[2] & /*prev_filterText*/
    131072) {
      $:
        if (filterText !== prev_filterText)
          setupFilterText();
    }
    if ($$self.$$.dirty[0] & /*filterText, multiple, value, itemId, label*/
    12824 | $$self.$$.dirty[1] & /*filter, items, groupBy, itemFilter*/
    407896064 | $$self.$$.dirty[2] & /*loadOptions, filterSelectedItems*/
    3) {
      $:
        $$invalidate(24, filteredItems = filter2({
          loadOptions,
          filterText,
          items,
          multiple,
          value,
          itemId,
          groupBy,
          label,
          filterSelectedItems,
          itemFilter,
          convertStringItemsToObjects,
          filterGroupedItems
        }));
    }
    if ($$self.$$.dirty[0] & /*multiple, listOpen, value, filteredItems*/
    16777800) {
      $:
        if (!multiple && listOpen && value && filteredItems)
          setValueIndexAsHoverIndex();
    }
    if ($$self.$$.dirty[0] & /*listOpen, multiple*/
    576) {
      $:
        if (listOpen && multiple)
          $$invalidate(7, hoverItemIndex = 0);
    }
    if ($$self.$$.dirty[0] & /*filterText*/
    16) {
      $:
        if (filterText)
          $$invalidate(7, hoverItemIndex = 0);
    }
    if ($$self.$$.dirty[0] & /*hoverItemIndex*/
    128) {
      $:
        dispatchHover(hoverItemIndex);
    }
    if ($$self.$$.dirty[0] & /*multiple, value*/
    520) {
      $:
        $$invalidate(25, hasValue = multiple ? value && value.length > 0 : value);
    }
    if ($$self.$$.dirty[0] & /*hasValue, filterText*/
    33554448) {
      $:
        $$invalidate(35, hideSelectedItem = hasValue && filterText.length > 0);
    }
    if ($$self.$$.dirty[0] & /*hasValue, disabled, loading*/
    33556512 | $$self.$$.dirty[2] & /*clearable*/
    64) {
      $:
        $$invalidate(34, showClear = hasValue && clearable && !disabled && !loading);
    }
    if ($$self.$$.dirty[0] & /*multiple, value*/
    520 | $$self.$$.dirty[1] & /*placeholderAlwaysShow, placeholder*/
    100663296) {
      $:
        $$invalidate(33, placeholderText = placeholderAlwaysShow && multiple ? placeholder : multiple && (value == null ? void 0 : value.length) === 0 ? placeholder : value ? "" : placeholder);
    }
    if ($$self.$$.dirty[0] & /*value, multiple*/
    520) {
      $:
        $$invalidate(32, ariaSelection = value ? handleAriaSelection(multiple) : "");
    }
    if ($$self.$$.dirty[0] & /*filteredItems, hoverItemIndex, focused, listOpen*/
    16777412) {
      $:
        $$invalidate(31, ariaContext = handleAriaContent({
          filteredItems,
          hoverItemIndex,
          focused,
          listOpen
        }));
    }
    if ($$self.$$.dirty[1] & /*items*/
    1048576) {
      $:
        updateValueDisplay(items);
    }
    if ($$self.$$.dirty[0] & /*multiple, value, itemId*/
    8712) {
      $:
        $$invalidate(52, justValue = computeJustValue(multiple, value, itemId));
    }
    if ($$self.$$.dirty[0] & /*multiple, value*/
    520 | $$self.$$.dirty[2] & /*prev_value*/
    65536) {
      $:
        if (!multiple && prev_value && !value)
          dispatch("input", value);
    }
    if ($$self.$$.dirty[0] & /*listOpen, filteredItems, multiple, value*/
    16777800) {
      $:
        if (listOpen && filteredItems && !multiple && !value)
          checkHoverSelectable();
    }
    if ($$self.$$.dirty[0] & /*filteredItems*/
    16777216) {
      $:
        handleFilterEvent(filteredItems);
    }
    if ($$self.$$.dirty[0] & /*container*/
    1 | $$self.$$.dirty[2] & /*floatingConfig*/
    4096) {
      $:
        if (container && (floatingConfig == null ? void 0 : floatingConfig.autoUpdate) === void 0) {
          $$invalidate(81, _floatingConfig.autoUpdate = true, _floatingConfig);
        }
    }
    if ($$self.$$.dirty[0] & /*container*/
    1 | $$self.$$.dirty[2] & /*floatingConfig, _floatingConfig*/
    528384) {
      $:
        if (container && floatingConfig)
          floatingUpdate(Object.assign(_floatingConfig, floatingConfig));
    }
    if ($$self.$$.dirty[0] & /*list*/
    8388608) {
      $:
        $$invalidate(30, listDom = !!list);
    }
    if ($$self.$$.dirty[0] & /*list, listOpen*/
    8388672) {
      $:
        listMounted(list, listOpen);
    }
    if ($$self.$$.dirty[0] & /*listOpen, container, list*/
    8388673) {
      $:
        if (listOpen && container && list)
          setListWidth();
    }
    if ($$self.$$.dirty[0] & /*hoverItemIndex*/
    128) {
      $:
        $$invalidate(29, scrollToHoverItem = hoverItemIndex);
    }
    if ($$self.$$.dirty[0] & /*input, listOpen, focused*/
    70) {
      $:
        if (input && listOpen && !focused)
          handleFocus();
    }
  };
  return [
    container,
    input,
    focused,
    value,
    filterText,
    loading,
    listOpen,
    hoverItemIndex,
    name,
    multiple,
    multiFullItemClearable,
    disabled,
    label,
    itemId,
    containerStyles,
    hasError,
    required,
    searchable,
    inputStyles,
    hideEmptyState,
    showChevron,
    containerClasses,
    handleClear,
    list,
    filteredItems,
    hasValue,
    activeValue,
    _inputAttributes,
    prefloat,
    scrollToHoverItem,
    listDom,
    ariaContext,
    ariaSelection,
    placeholderText,
    showClear,
    hideSelectedItem,
    handleMultiItemClear,
    handleKeyDown,
    handleFocus,
    handleBlur,
    handleClick,
    handleListScroll,
    handleClickOutside,
    handleHover,
    handleItemClick,
    isItemActive,
    activeScroll,
    hoverScroll,
    floatingRef,
    floatingContent,
    $$slots,
    items,
    justValue,
    filter2,
    getItems2,
    id,
    placeholder,
    placeholderAlwaysShow,
    itemFilter,
    groupBy,
    groupFilter,
    groupHeaderSelectable,
    loadOptions,
    filterSelectedItems,
    closeListOnChange,
    clearFilterTextOnBlur,
    createGroupHeaderItem,
    getFilteredItems,
    clearable,
    debounce,
    debounceWait,
    inputAttributes,
    listAutoWidth,
    listOffset,
    floatingConfig,
    ariaValues,
    ariaListOpen,
    ariaFocused,
    prev_value,
    prev_filterText,
    prev_multiple,
    _floatingConfig,
    $$scope,
    slots,
    keydown_handler_1,
    pointerup_handler,
    mousedown_handler,
    keydown_handler,
    mouseover_handler,
    focus_handler,
    click_handler,
    div_binding,
    pointerup_handler_1,
    click_handler_1,
    input_1_binding,
    input_1_input_handler,
    div3_binding
  ];
}
var Select = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance4,
      create_fragment4,
      safe_not_equal,
      {
        justValue: 52,
        filter: 53,
        getItems: 54,
        id: 55,
        name: 8,
        container: 0,
        input: 1,
        multiple: 9,
        multiFullItemClearable: 10,
        disabled: 11,
        focused: 2,
        value: 3,
        filterText: 4,
        placeholder: 56,
        placeholderAlwaysShow: 57,
        items: 51,
        label: 12,
        itemFilter: 58,
        groupBy: 59,
        groupFilter: 60,
        groupHeaderSelectable: 61,
        itemId: 13,
        loadOptions: 62,
        containerStyles: 14,
        hasError: 15,
        filterSelectedItems: 63,
        required: 16,
        closeListOnChange: 64,
        clearFilterTextOnBlur: 65,
        createGroupHeaderItem: 66,
        getFilteredItems: 67,
        searchable: 17,
        inputStyles: 18,
        clearable: 68,
        loading: 5,
        listOpen: 6,
        debounce: 69,
        debounceWait: 70,
        hideEmptyState: 19,
        inputAttributes: 71,
        listAutoWidth: 72,
        showChevron: 20,
        listOffset: 73,
        hoverItemIndex: 7,
        floatingConfig: 74,
        class: 21,
        handleClear: 22,
        ariaValues: 75,
        ariaListOpen: 76,
        ariaFocused: 77
      },
      add_css4,
      [-1, -1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Select",
      options,
      id: create_fragment4.name
    });
  }
  get justValue() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set justValue(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filter() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filter(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getItems() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set getItems(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get input() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set input(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiFullItemClearable() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiFullItemClearable(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focused() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set focused(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filterText() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filterText(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholderAlwaysShow() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholderAlwaysShow(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemFilter() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemFilter(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get groupBy() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set groupBy(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get groupFilter() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set groupFilter(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get groupHeaderSelectable() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set groupHeaderSelectable(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemId() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemId(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loadOptions() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loadOptions(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerStyles() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerStyles(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hasError() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hasError(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filterSelectedItems() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filterSelectedItems(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeListOnChange() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeListOnChange(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearFilterTextOnBlur() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clearFilterTextOnBlur(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get createGroupHeaderItem() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set createGroupHeaderItem(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getFilteredItems() {
    return this.$$.ctx[67];
  }
  set getFilteredItems(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searchable() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searchable(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputStyles() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputStyles(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearable() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clearable(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loading() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loading(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listOpen() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listOpen(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get debounce() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set debounce(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get debounceWait() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set debounceWait(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideEmptyState() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideEmptyState(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputAttributes() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputAttributes(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listAutoWidth() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listAutoWidth(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showChevron() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showChevron(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listOffset() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listOffset(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hoverItemIndex() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hoverItemIndex(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get floatingConfig() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set floatingConfig(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handleClear() {
    return this.$$.ctx[22];
  }
  set handleClear(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaValues() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaValues(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaListOpen() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaListOpen(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaFocused() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaFocused(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Select_default = Select;
export {
  Select_default as default
};
//# sourceMappingURL=svelte-select.js.map
